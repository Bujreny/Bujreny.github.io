<!DOCTYPE html>
<html>

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta content="yes" name="apple-mobile-web-app-capable" />
<meta content="black" name="apple-mobile-web-app-status-bar-style" />
<meta name="referrer" content="never">
<meta name="keywords" content="">
<meta name="description" content="欢迎访问[Buffoon&#39;s world]的个人博客">
<meta name="author" content="kveln">
<title>2.面向对象 | Buffoon&#39;s world</title>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/css/bootstrap.min.css">
<link href="https://cdn.bootcss.com/font-awesome/5.11.2/css/all.min.css" rel="stylesheet">
<link href='https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
<link
  href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800'
  rel='stylesheet' type='text/css'>
<link rel="alternate" type="application/rss+xml" title="2.面向对象 | Buffoon&#39;s world » Feed"
  href="https://bujreny.github.io/atom.xml">
<link rel="stylesheet"
  href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.15.10/build/styles/androidstudio.min.css">
<link href="https://bujreny.github.io/styles/main.css" rel="stylesheet">
<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>

<script src="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets/highlight.min.js"></script>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/850552586/ericamcdn@0.1/css/live2d.css">

<script>hljs.initHighlightingOnLoad();</script>

  <meta property="og:description" content="2.面向对象" />
  <meta property="og:url" content="https://bujreny.github.io/post/2mian-xiang-dui-xiang/" />
  <meta property="og:locale" content="zh-CN" />
  <meta property="og:type" content="website" />
  <meta property="og:site_name" content="Buffoon&#39;s world" />
  <!-- <script src="../assets/styles/scripts/tocScript.js"></script> -->
</head>

<body>
  <!-- Navigation -->
  <nav class="navbar navbar-expand-lg navbar-light fixed-top" id="mainNav">
  <div class="container">
    <a class="navbar-brand" href="https://bujreny.github.io">Buffoon&#39;s world</a>
    <button class="navbar-toggler navbar-toggler-right" type="button" data-toggle="collapse"
      data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false"
      aria-label="Toggle navigation">
      Menu
      <i class="fas fa-bars"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarResponsive">
      <ul class="navbar-nav ml-auto">
        
        <li class="nav-item">
          
          <a class="nav-link" href="/">首页</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/archives">归档</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/tags">标签</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/post/about">关于</a>
          
        </li>
        
        <li class="nav-item">
          <div class="gridea-search-container">
            <form id="gridea-search-form" style="position: relative" data-update="1678160248990"
              action="/search/index.html">
              <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
              <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 9px; left: 10px;"></i>
            </form>
          </div>
        </li>
      </ul>
    </div>
  </div>
</nav>
  <!-- Page Header -->
  <nav class="navbar navbar-expand-lg navbar-light fixed-top" id="mainNav">
  <div class="container">
    <a class="navbar-brand" href="https://bujreny.github.io">Buffoon&#39;s world</a>
    <button class="navbar-toggler navbar-toggler-right" type="button" data-toggle="collapse"
      data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false"
      aria-label="Toggle navigation">
      Menu
      <i class="fas fa-bars"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarResponsive">
      <ul class="navbar-nav ml-auto">
        
        <li class="nav-item">
          
          <a class="nav-link" href="/">首页</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/archives">归档</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/tags">标签</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/post/about">关于</a>
          
        </li>
        
        <li class="nav-item">
          <div class="gridea-search-container">
            <form id="gridea-search-form" style="position: relative" data-update="1678160248990"
              action="/search/index.html">
              <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
              <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 9px; left: 10px;"></i>
            </form>
          </div>
        </li>
      </ul>
    </div>
  </div>
</nav>
<header class="masthead" style="background-image: url('https://bujreny.github.io/media/images/home-bg.jpg')">
  <div class="overlay"></div>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-md-10 mx-auto">
        
          <!-- 没Title为其他页面Header -->
          
            <!-- 没Title并且有headerType为Post：文章Header -->
            <div class="post-heading">
              <span class="tags">
                
                <a href="https://bujreny.github.io/tag/K5xr0u5_H/" class="tag">JavaSE</a>
                
              </span>
              <h1>2.面向对象</h1>
              <span class="meta">
                Posted on
                2022-09-07，43 min read
              </span>
            </div>
          
        
      </div>
    </div>
  </div>
</header>
  <!-- Post Content -->
  <article id="post-content-article">
    <div class="container">
      <div class="row">
        <div class="col-lg-8 col-md-10 mx-auto post-content-container">
          
          <h1 id="面向对象">面向对象</h1>
<h2 id="类的定义-对象的创建">类的定义、对象的创建</h2>
<p>示例：</p>
<pre><code class="language-java">//  Dog.java
public class Dog {
//	成员变量
	public int age;
	public double weight;
	
//	方法
	public void run() {
		System.out.println(age + &quot;_&quot; + weight + &quot;_run&quot;);
	}
	public void eat(String food) {
		System.out.println(age + &quot;_&quot; + weight + &quot;_eat_&quot; + food);
	}

}
</code></pre>
<pre><code class="language-java">//  Main.java
public class Main {
	public static void main(String[] args) {
		Dog dog = new Dog();
		dog.age = 20;
		dog.weight = 5.6;
		dog.run();
		dog.eat(&quot;apple&quot;);
	}

}
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://cdn.jsdelivr.net/gh/buffoon-j/images/image-20220411102615936.png" alt="image-20220411102615936" loading="lazy"></figure>
<p><strong>成员变量（Member Variable）<strong>也叫</strong>字段（Field）</strong></p>
<h2 id="对象与数组的内存分析">对象与数组的内存分析</h2>
<h3 id="对象的内存">对象的内存</h3>
<p>Java中所有对象都是new出来的，所有对象的内存都是在<strong>堆空间</strong>。堆空间里面存的是成员变量，没有方法。</p>
<p>示例：</p>
<figure data-type="image" tabindex="2"><img src="https://cdn.jsdelivr.net/gh/buffoon-j/images/image-20220411103807269.png" alt="image-20220411103807269" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://cdn.jsdelivr.net/gh/buffoon-j/images/image-20220411103359149.png" alt="image-20220411103359149" loading="lazy"></figure>
<p>Java运行时环境有个<strong>垃圾回收器（garbage collector, 简称GC）</strong>，会自动回收不在使用的内存，即当一个对象没有任何引用时，会被CG回收掉内存。</p>
<h3 id="复杂对象的内存">复杂对象的内存</h3>
<p>示例：</p>
<pre><code class="language-java">//  Person.java
public class Person {
	public int age;
	public Dog dog;
}
</code></pre>
<pre><code class="language-java">//  Cat.java
public class Dog {
	public int price;
}
</code></pre>
<pre><code class="language-java">//  Main.java
public class Main {
	public static void main(String[] args) {
		Dog dog = new Dog();
		cat.price = 100;
		
		Person person = new Person();
		person.age = 20;
		person.dog = dog;
		
	}

}
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://cdn.jsdelivr.net/gh/buffoon-j/images/image-20220411105319922.png" alt="image-20220411105319922" loading="lazy"></figure>
<h3 id="对象数组的内存">对象数组的内存</h3>
<p>示例：</p>
<figure data-type="image" tabindex="5"><img src="https://cdn.jsdelivr.net/gh/buffoon-j/images/image-20220411110407013.png" alt="image-20220411110407013" loading="lazy"></figure>
<figure data-type="image" tabindex="6"><img src="https://cdn.jsdelivr.net/gh/buffoon-j/images/image-20220411110954832.png" alt="image-20220411110954832" loading="lazy"></figure>
<figure data-type="image" tabindex="7"><img src="https://cdn.jsdelivr.net/gh/buffoon-j/images/image-20220411111044735.png" alt="image-20220411111044735" loading="lazy"></figure>
<h2 id="内存区域划分">内存区域划分</h2>
<p>Java虚拟机在执行Java程序时会将内存划分为若干个不同的区域数据，主要有：</p>
<table>
<thead>
<tr>
<th>数据区域名称</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>PC寄存器（Program Counter Register）</td>
<td>存储 Java 虚拟机正在执行的字节码指令的地址</td>
</tr>
<tr>
<td>Java虚拟机栈（Java Virtual Machine Stack）</td>
<td>存储栈帧</td>
</tr>
<tr>
<td>堆（Heap）</td>
<td>存储 GC 所管理的各种对象</td>
</tr>
<tr>
<td>方法区（Method Area）</td>
<td>存储每一个类的结构信息（比如字段和方法信息、构造方法和普通方法的字节码等）</td>
</tr>
<tr>
<td>本地方法栈（Native MEthod Stack）</td>
<td>用来支持native方法的调用（比如用C编写的方法）</td>
</tr>
</tbody>
</table>
<h2 id="构造方法">构造方法</h2>
<h3 id="构造方法-2">构造方法</h3>
<p><strong>构造方法</strong>，也叫<strong>构造器</strong>，能够更方便的穿件一个对象。</p>
<p>构造方法有以下特点：</p>
<ul>
<li>方法名必须和类名一样</li>
<li>没有返回值类型</li>
<li>可以重载</li>
</ul>
<p>示例：</p>
<pre><code class="language-java">//Dog.java
public class Dog {
	public int age;
	public double weight;
//	构造方法
	public Dog() {}
	public Dog(int age) {
		this.age = age;
	}
	public Dog(int age, double weight) {
		this.age = age;
		this.weight = weight;
	}
}
</code></pre>
<pre><code class="language-java">//Main.java
public class Main {
	public static void main(String[] args) {
		Dog dog1 = new Dog();
		Dog dog2 = new Dog(18);
		Dog dog3 = new Dog(20, 6.66);
	}
}
</code></pre>
<p>建议：每个Java类都提供无参构造方法。</p>
<h3 id="this"><code>this</code></h3>
<p><code>this</code>是一个指向当前对象的引用，常见用途有：</p>
<ul>
<li>访问当前类中定义的成员变量</li>
<li>调用当前类中定义的方法（包括构造方法）</li>
</ul>
<p>示例：</p>
<pre><code class="language-java">//Cat.java
public class Cat {
	public String name;
	public int age;
	public int price;
	public Cat(String name, int age,int price) {
		this.name = name;
		this.age = age;
		this.price = price;
	}
	public Cat(String name) {
		this(name, 0, 0);
//      下面这两行调用run方法都没有报错，所以有时候this可以不用写
		this.run();
		run();
	}
	public void run() {
		System.out.println(&quot;Running!&quot;);
	}
}
</code></pre>
<p><code>this</code>的本质是一个隐藏的、位置靠前的方法参数。</p>
<p>示例：</p>
<pre><code class="language-java">//Dog.java
public class Dog {
	public int price;
	public void run() {
		System.out.println(price + &quot;_run&quot;);
	}
	public void eat() {
		System.out.println(price + &quot;_eat&quot;);
	}
}
</code></pre>
<pre><code class="language-java">//Main.java
public class Main {
	public static void main(String[] args) {
		Dog dog1 = new Dog();
		dog1.price = 100;
		dog1.run();
		dog1.eat();
		
		Dog dog2 = new Dog();
		dog2.price = 200;
		dog2.run();
		dog2.eat();
	}
}
</code></pre>
<p>在<strong>内存区域划分</strong>相关内容可以了解到，方法并没有和属性一起存储到栈帧中，而是存储在方法区的类的结构信息中。所以每个类只有这一份方法，那么两个对象调用一个方法，在目测没有传进去任何参数的情况下输出了不同的内容。其原因是<code>this</code>作为一个隐藏的、位置靠前的参数，在调用方法的时候把对象本身传了进去，所以可以做到两个<code>Dog</code>对象调用了方法区的同一份方法，却输出了不同的结果。</p>
<p><strong>注意（可以看<code>this</code>的第一个示例）：</strong></p>
<ul>
<li>只能在构造方法中使用<code>this</code>调用其他构造方法</li>
<li>如果在构造方法中调用了其它构造方法，构造方法调用构造方法的语句必须是语句中的第一条。</li>
</ul>
<h3 id="默认构造方法">默认构造方法</h3>
<p>如果一个类没有自定义构造方法，编译器会自动为它提供无参的默认构造方法。</p>
<p>**注意：**一旦自定义了构造方法，默认构造方法就不再存在。这一点可以利用IDEA的反编译功能打开编译的字节码文件（.class）和自己写的代码(.java)进行比对。</p>
<h2 id="包package">包（package）</h2>
<h3 id="包">包</h3>
<p>Java中的包就是其他编程语言中的命名空间，包的本质是文件夹（创建包后在本地资源管理器查看可以发现），常见作用：</p>
<ul>
<li>将不同的类进行组织管理、访问控制</li>
<li>解决命名冲突</li>
</ul>
<p>命名建议：</p>
<ul>
<li>为了保证包的唯一性，一般包名都是以公司域名的倒写开头，例如：com.orangestudio.*</li>
<li>全部小写（可以避免与某些类名或者接口名冲突）</li>
</ul>
<p>**注意：**类的第一句代码必须使用<code>package</code>声明自己属于哪个包。</p>
<p>示例：</p>
<figure data-type="image" tabindex="8"><img src="https://cdn.jsdelivr.net/gh/buffoon-j/images/image-20220414163013413.png" alt="image-20220414163013413" loading="lazy"></figure>
<figure data-type="image" tabindex="9"><img src="https://cdn.jsdelivr.net/gh/buffoon-j/images/image-20220414163118539.png" alt="image-20220414163118539" loading="lazy"></figure>
<p>如果公司域名有非法字符，建议添加下划线（_）来使包名合法化。</p>
<p>示例：</p>
<table>
<thead>
<tr>
<th style="text-align:center">域名</th>
<th style="text-align:center">软件包名称前缀</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">my-name.example.org</td>
<td style="text-align:center">org.example.my_name</td>
</tr>
<tr>
<td style="text-align:center">example.int</td>
<td style="text-align:center">int_.example</td>
</tr>
<tr>
<td style="text-align:center">123name.example,com</td>
<td style="text-align:center">com.example._123name</td>
</tr>
</tbody>
</table>
<h3 id="如何使用一个类">如何使用一个类</h3>
<p>要想正常使用一个类，必须要知道这个类的具体位置（在哪个包），有三种常见方式来使用一个类：</p>
<ul>
<li>
<p>使用类的全名</p>
<pre><code class="language-java">com.orangestudio.study.Dog dog = new com.orangestudio.study.Dog();
</code></pre>
</li>
<li>
<p>使用<code>import</code>导入指定类名</p>
<pre><code class="language-java">import com.orangestudio.study.Dog;
public class Main {
	public static void main(String[] args) {
		Dog dog = new Dog();
	}
}
</code></pre>
</li>
<li>
<p>使用<code>import</code>导入整个包的所有类</p>
<pre><code class="language-java">import com.orangestudio.study.*;
public class Main {
	public static void main(String[] args) {
		Dog dog = new Dog();
	}
}
</code></pre>
</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>为了方便，java编译器会为每个源文件自动导入两个包
<ul>
<li>import java.lang.*（这个包提供了Java开发中最常用的一些类型）</li>
<li>import 源文件所在包 .*</li>
</ul>
</li>
<li>import aa.bb.*
<ul>
<li>仅仅是导入了直接存放在aa.bb包中的一些类型</li>
<li>并不包含bb包下其它包内的类型</li>
</ul>
</li>
</ul>
<h2 id="继承">继承</h2>
<h3 id="继承-2">继承</h3>
<p>示例：</p>
<pre><code class="language-java">// Person.java
public class Person {
	public int age;
	public void run() {
		System.out.println(age + &quot;_run&quot;);
	}
}
</code></pre>
<pre><code class="language-java">// Student.java
public class Student extends Person {
	public int no;
	public void study() {
		System.out.println(age + &quot;_&quot; + &quot;_study&quot;);
	}
}
</code></pre>
<pre><code class="language-java">// Main.java
public class Main {
	public static void main(String[] args) {
		Person person = new Person();
		person.age = 15;
		person.run();
		
		Student student = new Student();
		student.age = 20;
		student.no = 1;
		student.run();
		student.study();
	}
}
</code></pre>
<figure data-type="image" tabindex="10"><img src="https://cdn.jsdelivr.net/gh/buffoon-j/images/image-20220416184857478.png" alt="image-20220416184857478" loading="lazy"></figure>
<p>上面代码中两个对象在内存中的状态如图所示：</p>
<figure data-type="image" tabindex="11"><img src="https://cdn.jsdelivr.net/gh/buffoon-j/images/image-20220416185153962.png" alt="image-20220416185153962" loading="lazy"></figure>
<p>对象在堆内存储的时候，会把最顶级的父类成员变量放在最上面，然后依次放下一级的成员变量，最后放自己的成员变量。</p>
<h3 id="object类"><code>Object</code>类</h3>
<p>任何类最终都继承自<code>java.lang.Object</code>类，一般称他为基类。当你新建一个类的时候，这个类就会默认继承自<code>Object</code>类.</p>
<h3 id="同名成员变量">同名成员变量</h3>
<p>子类可以定义跟父类同名的成员变量（不推荐）。</p>
<p>示例：</p>
<pre><code class="language-java">// Person.java
public class Person {
	public int age = 1;
	
}

</code></pre>
<pre><code class="language-java">// Student.java
public class Student extends Person {
	public int age = 2;
	public void show() {
		System.out.println(age);
		System.out.println(this.age);
		System.out.println(super.age);
	}
}
</code></pre>
<pre><code class="language-java">// Main.java
public class Main {
	public static void main(String[] args) {
		Student student = new Student();
		student.show();
	}
}
</code></pre>
<figure data-type="image" tabindex="12"><img src="https://cdn.jsdelivr.net/gh/buffoon-j/images/image-20220416190900804.png" alt="image-20220416190900804" loading="lazy"></figure>
<h3 id="方法的重写">方法的重写</h3>
<p>重写：子类的<strong>实例方法</strong>签名与父类一样，也叫做覆盖、复写。</p>
<p>示例：</p>
<pre><code class="language-java">// Animal.java
public class Animal {
	public void speak() {
		System.out.println(&quot;Animal - speak&quot;);
	}
	public void run() {
		System.out.println(&quot;Animal - run&quot;);
	}
}
</code></pre>
<pre><code class="language-java">// Dog.java
public class Dog extends Animal {
	@Override
	public void speak() {
		super.speak();
		run();
		this.run();
		super.run();
		System.out.println(&quot;Dog - speak&quot;);
	}
	@Override
	public void run() {
		System.out.println(&quot;Dog - run&quot;);
	}
}
</code></pre>
<pre><code class="language-Java">// Main.java
public class Main {
	public static void main(String[] args) {
		new Dog().speak();
	}
}
</code></pre>
<figure data-type="image" tabindex="13"><img src="https://cdn.jsdelivr.net/gh/buffoon-j/images/image-20220416192336498.png" alt="image-20220416192336498" loading="lazy"></figure>
<p>**注意：**子类的实例方法必须与父类的实例方法签名一样，签名不一样不属于重写（方法签名包括方法名和参数类型），可以理解为重载。</p>
<p>注意：</p>
<ul>
<li>子类<code>override</code>的方法权限必须&gt;=父类的方法权限</li>
<li>如果子类<code>override</code>的方法返回值类型是A，父类的方法返回值类型是B，那么A==B或者，A是B的子类。</li>
<li>子类的类方法签名和父类一样，不能称之为重写。</li>
</ul>
<h3 id="super"><code>super</code></h3>
<p>常见用途：</p>
<ul>
<li>访问父类定义的成员变量</li>
<li>调用父类中定义的方法（包括<strong>构造方法</strong>）</li>
</ul>
<p>示例（与<em>方法的重写</em>中示例基本一致）：</p>
<pre><code class="language-java">// Animal.java
public class Animal {
	public Animal() {
		System.out.println(&quot;Animal - constuctor&quot;);
	}
	public void speak() {
		System.out.println(&quot;Animal - speak&quot;);
	}
	public void run() {
		System.out.println(&quot;Animal - run&quot;);
	}
}
</code></pre>
<pre><code class="language-java">// Dog.java
public class Dog extends Animal {
	public Dog() {
		super();
	}
	@Override
	public void speak() {
		super.speak();
		run();
		this.run();
		super.run();
		System.out.println(&quot;Dog - speak&quot;);
	}
	@Override
	public void run() {
		System.out.println(&quot;Dog - run&quot;);
	}
}
</code></pre>
<pre><code class="language-java">// Main.java
public class Main {
	public static void main(String[] args) {
		new Dog().speak();
	}
}
</code></pre>
<figure data-type="image" tabindex="14"><img src="https://cdn.jsdelivr.net/gh/buffoon-j/images/image-20220416195132920.png" alt="image-20220416195132920" loading="lazy"></figure>
<h3 id="构造方法细节">构造方法细节</h3>
<p>子类的构造方法必须先调用父类的构造方法，然后再执行后面的代码</p>
<p>**注意：**如果子类的构造方法没有显式调用父类的构造方法，编译器会自动调用父类无参的构造方法（若此时父类没有无参的构造方法，编译器将报错）。</p>
<h2 id="注解">注解</h2>
<p>常用注解：</p>
<ul>
<li><code>@override</code>告诉编译器这是一个重写后的方法。重写方法时，如果你的方法签名和父类方法不一样，会报错。</li>
<li><code>@SuppressWarnings(&quot;警告类别&quot;)</code>让编译器不生成警告信息。可以放在方法前（类前）来使方法内（类内）的所有这个类型警告都消失。使用方式：
<ul>
<li><code>@superWarnings({&quot;rawtypes&quot;, &quot;unused&quot;})</code>多个警告信息时，里面传入的是一个字符数组</li>
<li><code>@SuppressWarnings(&quot;unused&quot;)</code>单个警告</li>
</ul>
</li>
</ul>
<p>示例：</p>
<figure data-type="image" tabindex="15"><img src="https://cdn.jsdelivr.net/gh/buffoon-j/images/image-20220420170402714.png" alt="image-20220420170402714" loading="lazy"></figure>
<figure data-type="image" tabindex="16"><img src="https://cdn.jsdelivr.net/gh/buffoon-j/images/image-20220420170445538.png" alt="image-20220420170445538" loading="lazy"></figure>
<h2 id="访问控制">访问控制</h2>
<p>Java中有四个级别访问权限，从高到低：</p>
<ul>
<li><code>public</code>：在任何地方都可见。</li>
<li><code>protected</code>：仅在自己的包中、自己的子类中可见。</li>
<li><code>无修饰符（package-private、default、friendly)</code>：仅在自己的包中可见。</li>
<li><code>private</code>：仅在自己的类中可见。</li>
</ul>
<p>如图所示：</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">同一类</th>
<th style="text-align:center">同一包：库单元</th>
<th style="text-align:center">不同包子类</th>
<th style="text-align:center">不同包非子类（anywhere）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">public</td>
<td style="text-align:center">可以访问</td>
<td style="text-align:center">可以访问</td>
<td style="text-align:center">可以访问</td>
<td style="text-align:center">可以访问</td>
</tr>
<tr>
<td style="text-align:center">protected</td>
<td style="text-align:center">可以访问</td>
<td style="text-align:center">可以访问</td>
<td style="text-align:center">可以访问</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">无修饰符</td>
<td style="text-align:center">可以访问</td>
<td style="text-align:center">可以访问</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">private</td>
<td style="text-align:center">可以访问</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<p>注意事项：</p>
<ul>
<li>四个访问权限都可以修饰类的成员，比如成员变量、方法、嵌套类（Nested Class）等。</li>
<li>只有<code>public</code>和<code>无修饰符</code>可以修饰顶级类（Top-level Class，定义在最外面的类）。</li>
<li>上述四个访问权限不可以修饰局部类（Local Class）、局部变量。</li>
<li>一个Java源文件中可以定义多个顶级类，<code>public</code>顶级类的名字必须和文件名一样。</li>
</ul>
<h2 id="封装">封装</h2>
<p>为成员变量<code>private</code>化提供<code>public</code>的<code>getter</code>、<code>setter</code>。</p>
<p>示例：</p>
<pre><code class="language-java">public class Person {
	private int age;
	private String name;
	
	public int getAge() {
		return age;
	}
	public void setAge(int age) {
		this.age = age;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	
}
</code></pre>
<p>子类对象的内存中，包含父类中定义的<code>private</code>成员变量。可以通过<code>getter</code>、<code>setter</code>来对<code>private</code>成员变量进行访问。</p>
<h2 id="tostring方法"><code>toString</code>方法</h2>
<p>当打印一个对象时，会自动调用对象的<code>toString</code>方法，并将返回的字符串打印出来。</p>
<p><code>toString</code>代码如下：</p>
<figure data-type="image" tabindex="17"><img src="https://cdn.jsdelivr.net/gh/buffoon-j/images/image-20220420181858904.png" alt="image-20220420181858904" loading="lazy"></figure>
<p>所以我们可以通过重写<code>toString</code>方法来达到打印对象时输出自己要打印的东西</p>
<h2 id="static"><code>Static</code></h2>
<p><code>static</code>常用来修饰类的成员：成员变量、方法、嵌套类</p>
<h3 id="成员变量">成员变量</h3>
<p>被static修饰：类变量、静态变量、静态字段，特点：</p>
<ul>
<li>在程序运行过程中只占用一份固定的内存（存储在方法区）</li>
<li>可以通过实例、类访问</li>
</ul>
<p>没有被<code>static</code>修饰：实例变量，特点：</p>
<ul>
<li>在每个实例内部都有一份内存</li>
<li>只能通过实例访问，不可以通过类访问</li>
</ul>
<h3 id="方法">方法</h3>
<p>被<code>static</code>修饰：类方法、静态方法，特点：</p>
<ul>
<li>可以通过实例、类访问</li>
<li>内部不可以用<code>this</code></li>
<li>可以直接访问类变量、类方法</li>
<li>不可以直接访问实例变量、实例方法</li>
</ul>
<p>没有被<code>static</code>修饰：实例方法，特点：</p>
<ul>
<li>只能通过实例访问，不可以通过类访问</li>
<li>内部可以使用<code>this</code></li>
<li>可以直接访问实例变量、实例方法</li>
<li>可以直接访问类变量、类方法</li>
</ul>
<h3 id="注意">注意</h3>
<ul>
<li>不推荐试听实例访问类变量、类方法</li>
<li>在同一个类中，不能有同名的实例变量和类变量，不能有相同签名的实例方法和类方法</li>
</ul>
<h3 id="静态导入">静态导入</h3>
<p>使用静态导入后，可以省略类名访问静态成员（成员变量、方法、嵌套类）。</p>
<p>示例：</p>
<p>各文件位置情况如下：</p>
<figure data-type="image" tabindex="18"><img src="https://cdn.jsdelivr.net/gh/buffoon-j/images/image-20220427153554747.png" alt="image-20220427153554747" loading="lazy"></figure>
<pre><code class="language-Java">// Person.java
package com.orangestudio.study;

public class Person {
	public static int age = 1;
	public static void show() {
		System.out.println(&quot;age is &quot; + age);
	} 
	public static class Foot {
		public void run() {
			System.out.println(&quot;run&quot;);
		}
	}
}
</code></pre>
<pre><code class="language-java">// Main.java
package com.orangestudio;
import static com.orangestudio.study.Person.*;

public class Main {
	public static void main(String[] args) {
		System.out.println(age);
		show();
		Foot foot = new Foot();
		foot.run();
	}
}
</code></pre>
<figure data-type="image" tabindex="19"><img src="https://cdn.jsdelivr.net/gh/buffoon-j/images/image-20220427153738781.png" alt="image-20220427153738781" loading="lazy"></figure>
<p>常见使用：</p>
<pre><code class="language-java">import static java.lang.Math.PI;

public class Main {
	public static void main(String[] args) {
		System.out.println(2 * PI * 10);
		System.out.println(2 * PI * 20);
	}
}
</code></pre>
<p><strong>注意：</strong></p>
<ul>
<li>正常使用静态导入，可以消除一些重复的类名，提高代码可读性。</li>
<li>过度使用静态导入，会分不清静态成员是在哪个类中定义的，所以要谨慎使用静态导入。</li>
</ul>
<h3 id="成员变量初始化">成员变量初始化</h3>
<p>编译器会自动为未初始化的成员变量设置初始值。</p>
<p><strong>手动给实例变量提供初始值：</strong></p>
<pre><code class="language-java">//	在声明中
	public int age = 10;
//	在构造方法中
	public Main() {
		age = 10;
	}
//	在初始化块（初始化代码块、匿名代码块）中
	{
		age = 10;
	}
</code></pre>
<p>**初始化块(初始化代码块、匿名代码块)：**编译器会将初始化块复制到每个构造方法的头部，即每创建一个实例对象，就会执行一次初始化块。但在实际操作中，更多地会把公共的初始代码放在参数最多的构造方法里，然后其他构造方法调用这个参数最多的构造方法。</p>
<p><strong>手动给类变量提供初始值：</strong></p>
<pre><code class="language-java">//	在声明中
	public static int count = 10;
//	在静态初始化块（静态代码块）中
	static {
		count = 10;
	}
</code></pre>
<p>在<strong>静态代码块</strong>中：</p>
<ul>
<li>当一个类被初始化的时候执行静态代码块，且只执行一次。</li>
<li>当第一个类被主动使用时，JVM会对类进行初始化。</li>
</ul>
<p><strong>初始化代码块与静态初始化代码块</strong></p>
<p>一个类中可以有多个（静态）初始化块，按照在源码中出现的顺序被执行，静态初始化块要比初始化块先执行，具体示例及原因见：之前写的<a href="https://buffoon-j.github.io/post/ni-ming-dai-ma-kuai-yu-static-dai-ma-kuai/">匿名代码块与static代码块</a>。</p>
<p>如果一个类有父类，那么对这个类进行实例化操作的时候，会先对其父类进行初始化，然后对其进行初始化，然后执行其父类构造方法，然后执行其本身的构造方法，示例如下：</p>
<p>示例：</p>
<pre><code class="language-Java">// Person.java
public class Person {
	static {
		System.out.println(&quot;Person-----静态初始化块&quot;);
	}
	{
		System.out.println(&quot;Person-----初始化块&quot;);
	}
	public Person() {
		System.out.println(&quot;Person-----构造方法&quot;);
	}
	
}
</code></pre>
<pre><code class="language-Java">// Student.java
public class Student extends Person {
	static {
		System.out.println(&quot;Student-----静态初始化块&quot;);
	}
	{
		System.out.println(&quot;Student-----初始化块&quot;);
	}
	public Student() {
		System.out.println(&quot;Student-----构造方法&quot;);
	}	

}
</code></pre>
<pre><code class="language-Java">// Main.java
public class Main {
	public static void main(String[] args) {
		Student s1 = new Student();
		System.out.println(&quot;====================&quot;);
		Student s2 = new Student();
	}
}
</code></pre>
<figure data-type="image" tabindex="20"><img src="https://cdn.jsdelivr.net/gh/buffoon-j/images/image-20220427172536156.png" alt="image-20220427172536156" loading="lazy"></figure>
<h3 id="单例模式">单例模式</h3>
<p>如果一个类设计成单例模式，单么在程序运行过程中，这个类只能创建一个实例。一般需要具备的条件：</p>
<ul>
<li>私有的静态实例变量</li>
<li>构造方法私有化</li>
<li>公共的静态方法，返回唯一的实例</li>
</ul>
<p>实例：</p>
<pre><code class="language-java">// Rocket.java
// 饿汉式单例模式
public class Rocket {
//	私有的静态的实例变量
	private static Rocket instance = new Rocket();
//	构造方法私有化
	private Rocket() {}
//	公共的静态方法，返回唯一的实例
	public static Rocket getInstance() {
		return instance;
	}
}
</code></pre>
<pre><code class="language-java">// Main.java
public class Main {
	public static void main(String[] args) {
		Rocket r1 = Rocket.getInstance();
		Rocket r2 = Rocket.getInstance();
		Person p1 = new Person();
		Person p2 = new Person();
		int n1 = 10;
		int n2 = 20;
        int n3 = 20;
		System.out.println(r1 == r2);
		System.out.println(p1 == p2);
		System.out.println(n1 == n2);
		System.out.println(n2 == n3);
	}
}
</code></pre>
<figure data-type="image" tabindex="21"><img src="https://cdn.jsdelivr.net/gh/buffoon-j/images/image-20220501092912049.png" alt="image-20220501092912049" loading="lazy"></figure>
<blockquote>
<p><strong>补充</strong>：Java中<code>==</code>比较的是两个变量的值，基本类型在Java虚拟机栈中存放的是其表示的值，引用类型在Java虚拟机栈中存放的是对象在堆中的地址值。所以<code>==</code>比较基本数据类型，是比较其数值；比较引用类型，则是比较其是不是一个对象。</p>
</blockquote>
<p>另一种方式：</p>
<pre><code class="language-java">// 懒汉式单例模式,存在线程安全问题
public class Rocket {
	private static Rocket instance = null;
	private Rocket() {};
	public static Rocket getInstance() {
		if (instance == null) {
			instance = new Rocket();
		}
		return instance;
	}
}
</code></pre>
<h2 id="final_常量"><code>final</code>_常量</h2>
<h3 id="final"><code>final</code></h3>
<ul>
<li>被<code>final</code>修饰的类：不能被子类化，不能被继承。</li>
<li>被<code>final</code>修饰的方法：不能被重写。</li>
<li>被<code>final</code>修饰的变量：只能进行一次赋值。如果修饰成员变量，对象创建完，被<code>final</code>修饰的成员变量必须有值。</li>
</ul>
<h3 id="常量">常量</h3>
<p><strong>常量的写法：</strong></p>
<pre><code class="language-java">	public static final double PI = 3.141592653589;
	private static final int NOT_FOUND = -1;
</code></pre>
<p>如果将基本类型或字符串定义为常量，并且<strong>在编译时就能确定值</strong>，编译器会使用常量值代替各处的常量名（类似于C语言的宏替换），这种常量称为<strong>编译时常量（compile-time constant）</strong>。</p>
<h2 id="嵌套类_局部类">嵌套类_局部类</h2>
<h3 id="嵌套类nested-class">嵌套类（Nested Class）</h3>
<p>嵌套类（Nested Class）是定义在另一个类中的类，在嵌套类外层的类叫外部类（Outer Class），最外层的外部类叫顶级类（Top-level Class）。示例：</p>
<pre><code class="language-java">public class OuterClass {
//	静态嵌套类
	static class StaticNestedClass {
		
	}
//	非静态嵌套类（内部类）
	class InnerClass {
		
	}
}
</code></pre>
<h4 id="内部类inner-class">内部类（Inner Class）</h4>
<p>嵌套类：没有被<code>static</code>修饰的嵌套类，非静态嵌套类。</p>
<p>注意：</p>
<ul>
<li>跟实例变量、实例方法一样，内部类与外部类实例相关联。必须先创建外部类实例，然后利用外部类实例创建内部类实例；内部类不能定义除编译时常量以外的任何<code>static</code>成员。</li>
<li>内部类可以直接访问外部类中的所有成员（即使被声明为<code>private</code>）。</li>
<li>外部类可以直接访问内部类实例的成员变量、方法（即使被声明为<code>private</code>）。</li>
</ul>
<p>内部类与外部类内存分析：</p>
<pre><code class="language-java">//  Person.java
public class Person {
	private int age;
	public class Hand {
		private int weight;
	}
}
</code></pre>
<pre><code class="language-java">//  Main.java
public class Main {
	public static void main(String[] args) {
		Person p1 = new Person();
		Hand h1 = p1.new Hand();
		Person p2 = new Person();
		Hand h2Hand = p2.new Hand();
	}
}
</code></pre>
<p>程序内存分析如下：</p>
<figure data-type="image" tabindex="22"><img src="https://cdn.jsdelivr.net/gh/buffoon-j/images/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE.jpg" alt="未命名绘图" loading="lazy"></figure>
<p>内部类示例：</p>
<pre><code class="language-java">//  Company.java
public class Company {
	private String name;
	public Company(String name) {
		this.name = name;
	}
	public void fire(Employee e) {
		System.out.println(name + &quot; fire &quot; + e.no);
	}
	
	public class Employee {
		private int no;
		public Employee(int no) {
			this.no = no;
		}
		public void show() {
			System.out.println(name + &quot; : &quot; + no);
		}
	}
}
</code></pre>
<pre><code class="language-java">//  Main.java
public class Main {
	public static void main(String[] args) {
		Company company = new Company(&quot;Orange&quot;);
		Employee employee = company.new Employee(1);
		employee.show();
		company.fire(employee);
	}
}
</code></pre>
<figure data-type="image" tabindex="23"><img src="https://cdn.jsdelivr.net/gh/buffoon-j/images/image-20220620155658423.png" alt="image-20220620155658423" loading="lazy"></figure>
<p>内部类细节：</p>
<pre><code class="language-java">//  OuterClass.java
public class OuterClass {
	private int x= 1;
	public class InnerClass {
		private int x = 2;
		public void show() {
			System.out.println(x);
			System.out.println(this.x);
			System.out.println(OuterClass.this.x);
		}
	}
}
</code></pre>
<pre><code class="language-java">//  Main.java
public class Main {
	public static void main(String[] args) {
		new OuterClass().new InnerClass().show();
	}
}
</code></pre>
<figure data-type="image" tabindex="24"><img src="https://cdn.jsdelivr.net/gh/buffoon-j/images/image-20220620160247487.png" alt="image-20220620160247487" loading="lazy"></figure>
<p>外部类与内部类出现同名的成员变量时，可以通过<code>外部类名.this.成员变量名</code>访问外部类的成员变量。</p>
<h4 id="静态嵌套类static-nested-class">静态嵌套类（Static Nested Class）</h4>
<p>静态嵌套类：被<code>static</code>修饰的嵌套类。</p>
<p>注意：</p>
<ul>
<li>嵌套类在行为上就是一个顶级类，只是定义的代码写在了另一个类中。</li>
<li>对于一般的顶级类，静态嵌套类多了一些特殊的权限，例如可以直接访问外部类中的成员（即使被声明为<code>private</code>）。</li>
</ul>
<p>示例：</p>
<pre><code class="language-java">//  Person.java
public class Person {
	public static class Car {}
	public class House {}
}
</code></pre>
<pre><code class="language-java">//  Main.java
public class Main {
	public static void main(String[] args) {
		Person.Car car = new Person.Car();
		Person.House house = new Person.House();
	}
}
</code></pre>
<p>报错如下：</p>
<figure data-type="image" tabindex="25"><img src="https://cdn.jsdelivr.net/gh/buffoon-j/images/image-20220623093749499.png" alt="image-20220623093749499" loading="lazy"></figure>
<figure data-type="image" tabindex="26"><img src="https://cdn.jsdelivr.net/gh/buffoon-j/images/image-20220623093820877.png" alt="image-20220623093820877" loading="lazy"></figure>
<h4 id="什么情况下使用嵌套类">什么情况下使用嵌套类？</h4>
<ul>
<li>
<p>如果类A只用在类C内部，可以考虑将类A嵌套到类C中。</p>
<ul>
<li>封装性更好</li>
<li>程序包更加简化</li>
<li>增强可读性、维护性</li>
</ul>
<p>示例：</p>
<pre><code class="language-java">//  Person.java
public class Person {
	public void run() {
		Dog dog = new Dog();
	}
	public void walk() {
		Dog dog = new Dog();
	}
	private class Dog{}
}
</code></pre>
</li>
<li>
<p>如果类A需要经常访问类C的非公共成员，可以考虑将类A嵌套到类C中。</p>
<ul>
<li>另外可以根据需要将类A隐藏起来，不对外暴露。</li>
</ul>
</li>
<li>
<p>如果需要经常访问非公共的实例成员，设计成内部类（非静态嵌套类），否则设计成静态嵌套类（能静态尽量静态）。</p>
<ul>
<li>如果必须先有C实例，才能创建A实例，那么可以将A设计为C的内部类。</li>
</ul>
</li>
</ul>
<h3 id="局部类local-class">局部类（Local Class）</h3>
<p>局部类：定义在代码中的类（可以定义在方法中、for循环中、if语句中等）</p>
<p>注意：</p>
<ul>
<li>局部类不能定义除编译时常量以外的任何<code>static</code>成员。</li>
<li>局部类只能访问<code>final</code>或者有效<code>final</code>的局部变量。
<ul>
<li>从Java8开始，如果局部变量没有进行第二次赋值，就认定是有效<code>final</code>。</li>
</ul>
</li>
<li>局部类可以直接访问外部类中的所有成员（即使被声明为<code>private</code>）。
<ul>
<li>局部类只有定义在实例相关的代码块中，才能直接访问外部类中的实例变量。</li>
</ul>
</li>
</ul>
<p>示例：</p>
<pre><code class="language-java">//  TestLocalClass.java
public class TestLocalClass {
	private int a = 1;
	private static int b = 2;
	private static void test1() {}
	private void test2() {}
	public void test3() {
		int c = 2;
		class LocalClass {
			static final int d = 4;
			void test4() {
				System.out.println(a + b + c + d);
				test1();
				test2();
			}
		}
		new LocalClass().test4();
	}
}
</code></pre>
<pre><code class="language-java">//  Main.java
public class Main {
	public static void main(String[] args) {
		new TestLocalClass().test3();
	}
}
</code></pre>
<figure data-type="image" tabindex="27"><img src="https://cdn.jsdelivr.net/gh/buffoon-j/images/image-20220623111221659.png" alt="image-20220623111221659" loading="lazy"></figure>
<h2 id="抽象类_接口">抽象类_接口</h2>
<h3 id="抽象方法abstract-method">抽象方法（Abstract Method）</h3>
<p>抽象方法：被<code>abstract</code>修饰的实例方法。</p>
<p>特点：</p>
<ul>
<li>只有方法声明，没有方法实现（参数列表后面没有大括号，而是分号）</li>
<li>不能是<code>private</code>权限（因为定义抽象方法的目的是让子类去实现）</li>
<li>只能定义在抽象类、接口中</li>
</ul>
<h3 id="抽象类abstract-class">抽象类（Abstract Class）</h3>
<p>抽象类：被<code>abstract</code>修饰的类。</p>
<p>特点：</p>
<ul>
<li>可以定义抽象方法。</li>
<li>不能实例化，但可以自定义构造方法。</li>
<li>子类必须实现抽象父类中的所有抽象方法（除非子类也是一个抽象类）。</li>
<li>可以像非抽象类一样定义成员变量、常量、嵌套类型、初始化块、非抽象方法等。也就是说，抽象类也可以完全不定义抽象方法。</li>
</ul>
<p>使用场景：抽取子类的公共实现到抽象父类中，要求子类必须单独实现的定义成抽象方法。</p>
<p>示例：</p>
<pre><code class="language-java">//    Shape.java
public abstract class Shape {
	protected double area;
	protected double girth;
	public double getGrith() {
		return girth;
	}
	public double getArea() {
		return area;
	}
	public void show() {
		calculate();
		System.out.println(area + &quot;_&quot; + girth);
	}
	protected abstract void calculate();
}
</code></pre>
<pre><code class="language-java">//  Rectangle.java
public class Rectangle extends Shape {
	private double width;
	private double height;
	public Rectangle(double width, double height) {
		this.width = width;
		this.height = height;
	}
	@Override
	protected void calculate() {
		area = width * height;
		girth = (width + height) * 2;
	}
}
</code></pre>
<pre><code class="language-java">//  Circle.java
public class Circle extends Shape {
	private double radius;
	public Circle(double radius) {
		this.radius = radius;
	}
	@Override
	protected void calculate() {
		double half = Math.PI * radius;
		area = half * radius;
		girth = half * 2;
	}
}
</code></pre>
<pre><code class="language-java">//  Main.java
public class Main {
	public static void main(String[] args) {
		Rectangle rectangle = new Rectangle(10, 20);
		rectangle.show();
		Circle circle = new Circle(10);
		circle.show();
	}
}
</code></pre>
<figure data-type="image" tabindex="28"><img src="https://cdn.jsdelivr.net/gh/buffoon-j/images/image-20220623141736923.png" alt="image-20220623141736923" loading="lazy"></figure>
<h3 id="接口interface">接口（Interface）</h3>
<p>API（Application Programming Interface）：应用编程接口，提供给开发者调用的一组功能（无需提供源码）。</p>
<p>Java中的接口：一系列方法声明的集合，用来定义规范、标准。</p>
<p>示例：</p>
<blockquote>
<p>实现一个家教接口，家教有学生和老师，具备教孩子编程和足球的能力。实现孩子类有名字，可以进行学习，可以选择家教。</p>
</blockquote>
<pre><code class="language-java">// JiaJiaoAble.java

public interface JiaJiaoAble {
	public abstract void jiaoBianCheng(Child child);
	public abstract void jiaoZuQiu(Child child);
}
</code></pre>
<pre><code class="language-java">// Student.java

public class Student implements JiaJiaoAble {

	@Override
	public void jiaoBianCheng(Child child) {
		System.out.println(&quot;Student教&quot; + child.getName() + &quot;编程&quot;);
	}

	@Override
	public void jiaoZuQiu(Child child) {
		System.out.println(&quot;Student教&quot; + child.getName() + &quot;足球&quot;);
	}
	
}
</code></pre>
<pre><code class="language-java">//Teacher.java

public class Teacher implements JiaJiaoAble {

	@Override
	public void jiaoBianCheng(Child child) {
		System.out.println(&quot;Teacher教&quot; + child.getName() + &quot;编程&quot;);
	}

	@Override
	public void jiaoZuQiu(Child child) {
		System.out.println(&quot;Teacher教&quot; + child.getName() + &quot;足球&quot;);
	}

}
</code></pre>
<pre><code class="language-java">//Child.java

public class Child {
	private String name;

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}
	
	private JiaJiaoAble jiaJiao;
	
	public void study() {
		jiaJiao.jiaoBianCheng(this);
		jiaJiao.jiaoZuQiu(this);
	}

	public void setJiaJiao(JiaJiaoAble jiaJiao) {
		this.jiaJiao = jiaJiao;
	}
	public JiaJiaoAble getJiaJiao() {
		return jiaJiao;
	}
}
</code></pre>
<pre><code class="language-java">//Main.java

public class Main {
	public static void main(String[] args) {
		Child child = new Child();
		child.setName(&quot;Buffoon&quot;);
		child.setJiaJiao(new Student());
		child.study();
		System.out.println(&quot;--------------------------&quot;);
		child.setJiaJiao(new Teacher());
		child.study();
	}
}
</code></pre>
<figure data-type="image" tabindex="29"><img src="https://cdn.jsdelivr.net/gh/buffoon-j/images/image-20220826182931370.png" alt="image-20220826182931370" loading="lazy"></figure>
<h4 id="注意-2">注意</h4>
<ul>
<li>接口中可以定义：抽象方法、常量、嵌套类型。从java8开始可以定义：默认方法、静态方法（类方法）。
<ul>
<li>上述定义内容都是隐式<code>public</code>的，因此可以省略<code>public</code>关键字。</li>
<li>从java9开始可以定义<code>private</code>方法</li>
</ul>
</li>
<li>常量可以省略<code>static</code>、<code>final</code></li>
<li>抽象方法可以省略<code>abstact</code></li>
<li>不能自定义构造方法、不能定义（静态）初始化块、不能实例化。</li>
</ul>
<h4 id="接口细节">接口细节</h4>
<ul>
<li>接口名称可以在任何使用类型的地方使用</li>
<li>一个类可以通过<code>implements</code>关键字实现一个或多个接口
<ul>
<li>实现接口的类必须实现接口中定义的所有抽象方法，除非它是个抽象类</li>
<li>如果一个类实现的多个接口中有相同的抽象方法，只需要实现此方法一次</li>
<li><code>extends</code>和<code>implements</code>可以一起使用，<code>implements</code>必须写在<code>extends</code>后面</li>
<li>当父类、接口中方法签名一样时，那么返回值类型也必须一样</li>
</ul>
</li>
<li>一个接口可以通过<code>extends</code>关键字继承一个或多个接口
<ul>
<li>当多个父接口中的方法签名一样时，那么返回值类型也必须一样</li>
</ul>
</li>
</ul>
<h4 id="接口的升级问题">接口的升级问题</h4>
<p>如果需要接口升级（比如增加新的抽象方法），会导致大幅代码改动，以前实现接口的类都得改动。拖箱不在改动以前类的前提下进行接口升级，从java8开始，有两种方案：默认方法(Default Method)、静态方法(Static Method)</p>
<h5 id="默认方法default-method">默认方法(Default Method)</h5>
<p>用<code>default</code>修饰默认方法，默认方法只能是实例方法。</p>
<p>示例：</p>
<pre><code class="language-java">// JiaJiaoAble.java
public interface JiaJiaoAble {
	void jiaoBianCheng(Child child);
	default void jiaoZuQiu(Child child) {
		System.out.println(&quot;JiaJiaoAble-----jiaoZuQiu&quot;);
	}
}
</code></pre>
<pre><code class="language-java">//Student.java
public class Student implements JiaJiaoAble {
	@Override
	public void jiaoBianCheng(Child child) {
		System.out.println(&quot;Student-----jiaoBianCheng&quot;);
	}
}
</code></pre>
<pre><code class="language-java">//Teacher.java
public class Teacher implements JiaJiaoAble {

	@Override
	public void jiaoBianCheng(Child child) {
		System.out.println(&quot;Teacher-----jiaoBianCheng&quot;);
	}
	
	@Override
	public void jiaoZuQiu(Child child) {
		System.out.println(&quot;Teacher-----jiaoZuQiu&quot;);
	}
}
</code></pre>
<pre><code class="language-java">//Child.java
public class Child {
	private String name;

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}
	
	private JiaJiaoAble jiaJiao;
	
	public void study() {
		jiaJiao.jiaoBianCheng(this);
		jiaJiao.jiaoZuQiu(this);
	}

	public void setJiaJiao(JiaJiaoAble jiaJiao) {
		this.jiaJiao = jiaJiao;
	}
	public JiaJiaoAble getJiaJiao() {
		return jiaJiao;
	}
}
</code></pre>
<pre><code class="language-java">//Main.java
public class Main {
	public static void main(String[] args) {
		Child child = new Child();
		child.setName(&quot;Buffoon&quot;);
		child.setJiaJiao(new Student());
		child.study();
		System.out.println(&quot;--------------------------&quot;);
		child.setJiaJiao(new Teacher());
		child.study();
	}
}
</code></pre>
<figure data-type="image" tabindex="30"><img src="https://cdn.jsdelivr.net/gh/buffoon-j/images/image-20220827155453530.png" alt="image-20220827155453530" loading="lazy"></figure>
<p>使用：</p>
<ul>
<li>一个类实现的接口中有默认方法时，这个类可以
<ul>
<li>沿用接口的默认实现</li>
<li>重新定义默认方法，覆盖默认方法的实现</li>
<li>重新声明默认方法，将默认方法声明为抽象方法（此类必须是抽象类）</li>
</ul>
</li>
<li>当一个接口继承的父接口中有默认方法时，这个接口可以：
<ul>
<li>沿用接口的默认实现</li>
<li>重新定义默认方法，覆盖默认方法的实现</li>
<li>重新声明默认方法，将默认方法声明为抽象方法</li>
</ul>
</li>
</ul>
<p>细节：</p>
<ul>
<li>如果父类定义的非抽象方法与接口的默认方法相同时，最终将调用父类的方法</li>
<li>如果父类定义的抽象方法与接口的默认方法相同时，要求子类实现此抽象方法。可以通过<code>super</code>关键字调用接口的默认方法。<code>接口名.super.方法名</code></li>
<li>如果（父）接口定义的默认方法与其他（父）接口定义的方法相同时，要求子类型实现此默认方法。</li>
</ul>
<h5 id="静态方法static-method">静态方法(Static Method)</h5>
<p>接口中定义的静态方法只能通过接口名调用，不能被继承。</p>
<p>示例：</p>
<pre><code class="language-java">//Runnable.java
public interface Runnable {
	static void run(String name) {
		System.out.println(&quot;Runnable - run - &quot; + name);
	}
}
</code></pre>
<pre><code class="language-java">//Main.java
public class Main {
	public static void main(String[] args) {
		Runnable.run(&quot;小明&quot;);
	}
}
</code></pre>
<figure data-type="image" tabindex="31"><img src="https://cdn.jsdelivr.net/gh/buffoon-j/images/image-20220831181741822.png" alt="image-20220831181741822" loading="lazy"></figure>
<h3 id="抽象类与接口对比">抽象类与接口对比</h3>
<p>区别：</p>
<ul>
<li>抽象类：<code>A extends B</code>，A是B</li>
<li>接口：<code>A implements B</code>, A会 B的行为</li>
</ul>
<p>何时选择抽象类：</p>
<ul>
<li>在紧密相关的类之间共享代码</li>
<li>需要除<code>public</code>之外的访问权限</li>
<li>需要定义实例变量、非<code>final</code>的静态变量</li>
</ul>
<p>何时选择接口：</p>
<ul>
<li>不相关的类实现相同的方法</li>
<li>知识定义行为，不关心具体是谁实现了行为</li>
<li>想实现类型的多重继承</li>
</ul>
<h2 id="多态polymorphism">多态（Polymorphism）</h2>
<p><strong>多态</strong>通俗的来说是具有多种形态，具体的来说是统一操作作用于不用的对象，产生不同的执行结果。</p>
<p>体现：</p>
<ul>
<li>父类（接口）类型指向子类对象</li>
<li>调用子类重写方法</li>
</ul>
<p>JVM会根据引用变量指向的具体对象来调用对应的方法。这个行为叫做<strong>虚方法调用（virtual method invocation）</strong>,类似于C++中的虚函数调用。</p>
<p>示例1：</p>
<pre><code class="language-java">//Animal.java
public class Animal {
	public void speak() {
		System.out.println(&quot;Animal-----speak&quot;);
	}
}
</code></pre>
<pre><code class="language-java">//Dog.java
public class Dog extends Animal {
	@Override
	public void speak() {
		System.out.println(&quot;Dog-----wangwang&quot;);
	}
}
</code></pre>
<pre><code class="language-java">//Cat.java
public class Cat extends Animal {
	@Override
	public void speak() {
		System.out.println(&quot;Cat-----miaomiao&quot;);
	}
}
</code></pre>
<pre><code class="language-java">//Main.java
public class Main {
	public static void main(String[] args) {
		speak(new Dog());
		speak(new Cat());
	}
	static void speak(Animal animal) {
		animal.speak();
	}

</code></pre>
<figure data-type="image" tabindex="32"><img src="https://cdn.jsdelivr.net/gh/buffoon-j/images/image-20220831184143800.png" alt="image-20220831184143800" loading="lazy"></figure>
<p>示例2：</p>
<pre><code class="language-java">//Runnable.java
public interface Runnable {
	void run();
}
</code></pre>
<pre><code class="language-java">//Pig.java
public class Pig implements Runnable {
	@Override
	public void run() {
		System.out.println(&quot;Pig---run&quot;);
	}	
}
</code></pre>
<pre><code class="language-java">//Person.java
public class Person implements Runnable {
	@Override
	public void run() {
		System.out.println(&quot;Person---run&quot;);
	}
}
</code></pre>
<pre><code class="language-java">//Main.java
public class Main {
	public static void main(String[] args) {
		run(new Pig());
		run(new Person());
	}
	static void run(Runnable runnable) {
		runnable.run();
	}
}
</code></pre>
<figure data-type="image" tabindex="33"><img src="https://cdn.jsdelivr.net/gh/buffoon-j/images/image-20220831185635128.png" alt="image-20220831185635128" loading="lazy"></figure>
<h3 id="类方法调用细节">类方法调用细节</h3>
<ul>
<li>Java中子类重写父类方法覆盖的是实例方法不是类方法（静态方法），类方法的调用只和类相关。</li>
</ul>
<p>示例：</p>
<pre><code class="language-java">//Animal.java
public class Animal {
	public static void run() {
		System.out.println(&quot;Animal---run&quot;);
	}
}
</code></pre>
<pre><code class="language-java">//Dog.java
public class Dog extends Animal {
	public static void run() {
		System.out.println(&quot;Dog---run&quot;);
	}
}
</code></pre>
<pre><code class="language-java">//Main.java
public class Main {
	public static void main(String[] args) {
		Dog.run();
		Animal.run();
		Dog dog1 = new Dog();
		dog1.run();
		Animal dog2 = new Dog();
		dog2.run();
	}
}
</code></pre>
<figure data-type="image" tabindex="34"><img src="https://cdn.jsdelivr.net/gh/buffoon-j/images/image-20220902120633391.png" alt="image-20220902120633391" loading="lazy"></figure>
<h3 id="父类声明子类实例化成员变量的访问细节">父类声明子类实例化（成员变量的访问细节）</h3>
<p>理解：</p>
<ul>
<li>使用父类类型的引用指向子类的对象。</li>
<li>该引用只能调用父类中定义的方法和变量。</li>
<li>如果子类中重写了父类的一个方法，那么在调用这个方法的时候，将会调用子类中的这个方法。（动态连接、动态调用）</li>
<li>变量不能被重写（覆盖），“重写”的概念只针对方法，如果在子类中“重写“了父类中的变量，那么编译时会报错。</li>
</ul>
<p>示例：</p>
<pre><code class="language-java">//Person.java
public class Person {
	public int age = 1;
	public int getPAge() {
		return age;
	}
}
</code></pre>
<pre><code class="language-java">//Student.java
public class Student extends Person {
	public int age = 2;
	public int getSAge() {
		return age;
	}
}
</code></pre>
<pre><code class="language-java">//Teacher.java
public class Teacher extends Person {
	public int age = 3;
	@Override
	public int getPAge() {
		return age;
	}
	public int getTAge() {
		return age;
	}
}

</code></pre>
<pre><code class="language-java">//Main.java
public class Main {
	public static void main(String[] args) {
		Student stu1 = new Student();
		System.out.println(stu1.age);
		System.out.println(stu1.getPAge());
		System.out.println(stu1.getSAge());
		System.out.println(&quot;----------&quot;);
		Person stu2 = new Student();
		System.out.println(stu2.age);
		System.out.println(stu2.getPAge());
		System.out.println(&quot;**********&quot;);
		Teacher tea1 = new Teacher();
		System.out.println(tea1.age);
		System.out.println(tea1.getPAge());
		System.out.println(tea1.getTAge());
		System.out.println(&quot;----------&quot;);
		Person tea2 = new Teacher();
		System.out.println(tea2.age);
		System.out.println(tea2.getPAge());
	}
}
</code></pre>
<figure data-type="image" tabindex="35"><img src="https://cdn.jsdelivr.net/gh/buffoon-j/images/image-20220902132149141.png" alt="image-20220902132149141" loading="lazy"></figure>
<p>参考：<a href="https://blog.csdn.net/weixin_40449300/article/details/84558692">Teingi.  【java基础】——java中父类声明子类实例化</a></p>
<h3 id="instanceof">instanceof</h3>
<p>可以通过<code>instanceof</code>判断某个类型是否属于某种类型</p>
<p>示例：</p>
<pre><code class="language-java">//Animal.java
public class Animal {}
</code></pre>
<pre><code class="language-java">//Cat.java
public class Cat extends Animal {
	public void miao() {
		System.out.println(&quot;Cat---miao&quot;);
	}
}
</code></pre>
<pre><code class="language-java">//Dog.java
public class Dog extends Animal {
	public void wang() {
		System.out.println(&quot;Dog---wang&quot;);
	}
}
</code></pre>
<pre><code class="language-java">//Main.java
public class Main {
	public static void main(String[] args) {
		speak(new Dog());
		speak(new Cat());
	}
	static void speak(Animal animal) {
		if (animal instanceof Dog) {
			((Dog)animal).wang();
		}else if (animal instanceof Cat) {
			((Cat)animal).miao();
		}
	}
}
</code></pre>
<figure data-type="image" tabindex="36"><img src="https://cdn.jsdelivr.net/gh/buffoon-j/images/image-20220902170849517.png" alt="image-20220902170849517" loading="lazy"></figure>
<h2 id="匿名类anonymous-class">匿名类（Anonymous Class）</h2>
<p>当接口、抽象类的实现类，在整个项目中只用过一次，可以考虑使用匿名类。</p>
<p>示例：</p>
<pre><code class="language-java">//Eatable.java
public interface Eatable {
	String name();
	int energy();
}
</code></pre>
<pre><code class="language-java">//Person.java
public class Person {
	public void eat(Eatable e) {
		System.out.println(
				&quot;eat---&quot; + e.name()
				+&quot;---&quot; + e.energy());
	}
}
</code></pre>
<pre><code class="language-java">//Main.java
public class Main {
	public static void main(String[] args) {
		Person person = new Person();
		person.eat(new Eatable() {
			
			@Override
			public String name() {
				return &quot;Apple&quot;;
			}
			
			@Override
			public int energy() {
				return 100;
			}
		});
	}
}
</code></pre>
<figure data-type="image" tabindex="37"><img src="https://cdn.jsdelivr.net/gh/buffoon-j/images/image-20220903145502320.png" alt="image-20220903145502320" loading="lazy"></figure>
<h3 id="使用注意">使用注意</h3>
<ul>
<li>匿名类不能定义除编译时常量以外的任何<code>static</code>成员。</li>
<li>匿名类只能访问<code>final</code>或者有效<code>final</code>的局部变量。</li>
<li>匿名类可以直接访问外部类中的所有成员（即使被声明为<code>private</code>）。匿名类只有在实例相关的代码块中使用，才能访问外部类中的实例成员（实例变量、实例方法）。</li>
<li>匿名类不能自定义构造方法，但可以有初始化块。</li>
<li>匿名类常用于：代码传递、过滤器、回调。</li>
</ul>
<h3 id="常见用途及伪代码示例">常见用途及伪代码示例</h3>
<ul>
<li>传递代码：写一个工具类，统计某一段代码的执行时间。</li>
</ul>
<p>目录结构如图所示：</p>
<figure data-type="image" tabindex="38"><img src="https://cdn.jsdelivr.net/gh/buffoon-j/images/image-20220903163736181.png" alt="image-20220903163736181" loading="lazy"></figure>
<pre><code class="language-java">//Times.java
package com.orangestudio.util;

public class Times {
	public interface Block{
		void execute();
	}

	public static void test(Block block) {
		long begin = System.currentTimeMillis();
		block.execute();
		long end = System.currentTimeMillis();
		double duration = (end - begin) / 1000.0;
		System.out.println(&quot;耗时：&quot; + duration + &quot;s&quot;);
	}
}
</code></pre>
<pre><code class="language-java">//Main.java
package com.orangestudio;

import com.orangestudio.util.Times;
import com.orangestudio.util.Times.Block;

public class Main {
	public static void main(String[] args) {
		Times.test(new Block() {
			
			@Override
			public void execute() {
				test();
			}
		});
	}
	static void test() {
		int age = 100000;
		String string = &quot;&quot;;
		for (int i = 0; i &lt; age; i++) {
			string += i;
		}
	}
}
</code></pre>
<figure data-type="image" tabindex="39"><img src="https://cdn.jsdelivr.net/gh/buffoon-j/images/image-20220903163842722.png" alt="image-20220903163842722" loading="lazy"></figure>
<ul>
<li>回调：根据URL发送一个异步请求（开启一条子线程），请求完毕后进行一些操作。</li>
</ul>
<p>目录结构如图所示：</p>
<figure data-type="image" tabindex="40"><img src="https://cdn.jsdelivr.net/gh/buffoon-j/images/image-20220905094349973.png" alt="image-20220905094349973" loading="lazy"></figure>
<pre><code class="language-java">//Networks.java
package com.orangestudio.util;

public class Networks {
	public interface Block{
		void sucess(Object reponse);
		void failure();
	}
	
	public static void get(String url, Block callback) {
//		假设传递成功
		boolean result = true;
		if (result) {
			Object reponse = null;
			callback.sucess(reponse);
		} else {
			callback.failure();
		}
	}
}
</code></pre>
<pre><code class="language-java">//Main.java
package com.orangestudio;

import com.orangestudio.util.Networks;
import com.orangestudio.util.Networks.Block;

public class Main {
	public static void main(String[] args) {
		Networks.get(&quot;htps://xxxxxx.com?name=qwe&amp;age=18&quot;, new Block() {
			
			@Override
			public void sucess(Object reponse) {
				System.out.println(&quot;请求成功。&quot;);
			}
			
			@Override
			public void failure() {
				System.out.println(&quot;请求失败。&quot;);
			}
		});
	}
}
</code></pre>
<figure data-type="image" tabindex="41"><img src="https://cdn.jsdelivr.net/gh/buffoon-j/images/image-20220905094709670.png" alt="image-20220905094709670" loading="lazy"></figure>
<ul>
<li>过滤器：传入文件夹地址，将文件夹下包含类的文件名过滤出来。</li>
</ul>
<p>目录结构如图所示：<br>
<img src="https://cdn.jsdelivr.net/gh/buffoon-j/images/image-20220905144146808.png" alt="image-20220905144146808" loading="lazy"></p>
<pre><code class="language-java">//Files.java
package com.orangestudio.util;

public class Files {
	public interface Filter {
		boolean accept(String filename);
	}
	public static String[] getAllFilenames(String dir, Filter filter) {
//		1. 先获取dir文件夹下的所有文件名
		String[] allFilenames = {};
//		2. 进行过滤
		for(String filename : allFilenames) {
			if (filter.accept(filename)) {
//				将这个文件名封装起来
			}
		}
//		3. 返回所有装起来的文件名
		return null;
	}
}
</code></pre>
<pre><code class="language-java">//Main.java
package com.orangestudio;

import com.orangestudio.util.Files;
import com.orangestudio.util.Files.Filter;

public class Main {
	public static void main(String[] args) {
		Files.getAllFilenames(&quot;C:&quot;, new Filter() {
			
			@Override
			public boolean accept(String filename) {
				return filename.contains(&quot;类&quot;);
			}
		});
	}
}
</code></pre>
<h3 id="排序">排序</h3>
<ul>
<li>可以使用JDK自带的<code>java.util.Arrays</code>类对数组进行排序</li>
</ul>
<p>示例：</p>
<pre><code class="language-java">//Main.java
import java.util.Arrays;
import java.util.Comparator;

public class Main {
	public static void main(String[] args) {
		Integer[] array = {33, 22, 11, 77, 66, 99};
		Arrays.sort(array);
		System.out.println(Arrays.toString(array));
		
		Arrays.sort(array, new Comparator&lt;Integer&gt;() {
			@Override
			public int compare(Integer o1, Integer o2) {
				return o2 - o1;
			}
		});
		
	System.out.println(Arrays.toString(array));
	}
}
</code></pre>
<figure data-type="image" tabindex="42"><img src="https://cdn.jsdelivr.net/gh/buffoon-j/images/image-20220905150957496.png" alt="image-20220905150957496" loading="lazy"></figure>
<ul>
<li>关于<code>compare()</code>的返回值
<ul>
<li>等于0，o1==o2</li>
<li>大于0，o1&gt;o2</li>
<li>小于0，o1&lt;o2</li>
</ul>
</li>
</ul>
<h4 id="comparable-vs-comparator">Comparable vs Comparator</h4>
<ul>
<li>如果数组元素本身具备可比较性（实现了<code>java.util.Comparable</code>接口）
<ul>
<li>可以直接使用<code>Arrats.sort</code>方法进行排序</li>
</ul>
</li>
<li><code>java.util.Comparator</code>的存在意义
<ul>
<li>可以在不修改类源代码的前提下，修改默认的比较方式（比如官方类、第三方类）</li>
<li>可以让一个类提供多种比较方式</li>
</ul>
</li>
</ul>
<h2 id="lambda-expression">Lambda Expression</h2>
<ul>
<li>Lambda表达式是Java8开始才有的语法，发音：美 [ˈlæmdə]</li>
</ul>
<p><strong>函数式接口（Functional Inferface）</strong></p>
<ul>
<li>
<p>函数式接口（Functional Inferface）:只包含一个抽象方法的接口</p>
<ul>
<li>可以在接口上面加<code>@FunctionalInterface</code>注解，表示它是一个函数式接口</li>
</ul>
</li>
<li>
<p>当匿名类实现的是函数式接口时，可以使用Lambda表达式进行简化</p>
</li>
</ul>
<p><strong>Lambda表达式格式：</strong></p>
<p>(参数列表) -&gt; {</p>
<p>代码</p>
<p>return xxx;</p>
<p>}</p>
<p><strong>书写规则：</strong></p>
<ul>
<li>参数列表可以省略参数类型</li>
<li>当只有一条语句时，可以省略大括号、分号、<code>return</code></li>
<li>当只有一个参数时，可以省略小括号</li>
<li>当没有参数时，不能省略小括号</li>
</ul>
<p>示例1：</p>
<p>对之前 “传递代码：写一个工具类，统计某一段代码的执行时间” 进行优化。</p>
<p>目录结构如图所示：</p>
<figure data-type="image" tabindex="43"><img src="https://cdn.jsdelivr.net/gh/buffoon-j/images/image-20220907112612533.png" alt="image-20220907112612533" loading="lazy"></figure>
<pre><code class="language-java">//Times.java
package com.orangestudio.util;

public class Times {
    @FunctionalInterface
	public interface Block{
		void execute();
	}

	public static void test(Block block) {
		long begin = System.currentTimeMillis();
		block.execute();
		long end = System.currentTimeMillis();
		double duration = (end - begin) / 1000.0;
		System.out.println(&quot;耗时：&quot; + duration + &quot;s&quot;);
	}
}
</code></pre>
<pre><code class="language-java">//Main.java------只改动了这里
package com.orangestudio;

import com.orangestudio.util.Times;

public class Main {
	public static void main(String[] args) {
		Times.test(() -&gt; {
			int age = 100000;
			String string = &quot;&quot;;
			for (int i = 0; i &lt; age; i++) {
				string += i;
			}
		});
	}
}
</code></pre>
<figure data-type="image" tabindex="44"><img src="https://cdn.jsdelivr.net/gh/buffoon-j/images/image-20220907112636440.png" alt="image-20220907112636440" loading="lazy"></figure>
<p>示例2：</p>
<p>写一个工具类，实现两数相加功能，并最后输出。</p>
<p>目录结构如图所示：</p>
<figure data-type="image" tabindex="45"><img src="https://cdn.jsdelivr.net/gh/buffoon-j/images/image-20220907120657795.png" alt="image-20220907120657795" loading="lazy"></figure>
<pre><code class="language-java">//Calculators.java
package com.orangestudio.util;

public class Calculators {
	@FunctionalInterface
	public interface Calculator {
		int calculate(int v1, int v2);
	}
	
	public static void execute(int v1, int v2, Calculator c) {
		System.out.println(c.calculate(v1, v2));
	}
}
</code></pre>
<pre><code class="language-java">//Main.java
package com.orangestudio;

import com.orangestudio.util.Calculators;

public class Main {
	public static void main(String[] args) {
		Calculators.execute(10, 20, (int v1, int v2) -&gt; {
			return v1 + v2;
		});
		
		Calculators.execute(11, 22, (v1, v2) -&gt; v1 + v2);
	}
}
</code></pre>
<figure data-type="image" tabindex="46"><img src="https://cdn.jsdelivr.net/gh/buffoon-j/images/image-20220907120945019.png" alt="image-20220907120945019" loading="lazy"></figure>
<p><strong>使用注意</strong>：</p>
<ul>
<li>Lambda只能访问<code>final</code>或者有效<code>final</code>的局部变量</li>
<li>Lambda没有引入新的作用域，匿名类引入了新的作用域</li>
</ul>
<p>示例：</p>
<pre><code class="language-java">//Testable.java
@FunctionalInterface
public interface Testable {
	void test(int v);
}
</code></pre>
<pre><code class="language-java">//OuterClass.java
public class OuterClass {
	private int age = 1;
	
	public class InnerClass {
		private int age = 2;
		void inner() {
//			int v = 4; //Error!
			Testable t = v -&gt; {
				System.out.println(v);
				System.out.println(age);
				System.out.println(this.age);
				System.out.println(InnerClass.this.age);
				System.out.println(OuterClass.this.age);
			};
			t.test(3);
		}
	}
	
	public static void main(String[] args) {
		new OuterClass().new InnerClass().inner();
	}
}
</code></pre>
<figure data-type="image" tabindex="47"><img src="https://cdn.jsdelivr.net/gh/buffoon-j/images/image-20220907161215493.png" alt="image-20220907161215493" loading="lazy"></figure>
<h3 id="方法引用method-reference">方法引用（Method Reference）</h3>
<p>如果Lambda中的内容仅仅是调用某个方法，可以使用**方法引用(Method Reference)**来简化。</p>
<figure data-type="image" tabindex="48"><img src="https://cdn.jsdelivr.net/gh/buffoon-j/images/image-20220907162619520.png" alt="image-20220907162619520" loading="lazy"></figure>
<h4 id="引用类方法">引用类方法</h4>
<pre><code class="language-java">//Testable.java
@FunctionalInterface
public interface Testable {
	int test(int v1,int v2);
}
</code></pre>
<pre><code class="language-java">//Main.java
public class Main {
	public static void main(String[] args) {
		Testable t1 = (v1, v2) -&gt; Math.max(v1,v2);
		System.out.println(t1.test(10, 20));
		
		Testable t2 = Math::max;
		System.out.println(t2.test(10, 20));
	}	
}
</code></pre>
<figure data-type="image" tabindex="49"><img src="https://cdn.jsdelivr.net/gh/buffoon-j/images/image-20220907163708794.png" alt="image-20220907163708794" loading="lazy"></figure>
<h4 id="引用特定对象实例方法">引用特定对象实例方法</h4>
<pre><code class="language-java">//Testable.java
@FunctionalInterface
public interface Testable {
	void test(int v);
}
</code></pre>
<pre><code class="language-java">//Person.java
public class Person {
	public void setAge(int age) {
		System.out.println(&quot;Person - setAge - &quot; + age);
	}
}
</code></pre>
<pre><code class="language-java">//Main.java
public class Main {
	static void execute(Testable t, int v) {
		t.test(v);
	}
	
	public static void main(String[] args) {
		execute(v -&gt; System.out.println(v), 10);
		execute(v -&gt; new Person().setAge(v), 10);
		execute(System.out::println, 20);
		execute(new Person()::setAge, 20);
	}
}
</code></pre>
<figure data-type="image" tabindex="50"><img src="https://cdn.jsdelivr.net/gh/buffoon-j/images/image-20220907165155935.png" alt="image-20220907165155935" loading="lazy"></figure>
<h4 id="引用特定类型的任意对象的实例方法">引用特定类型的任意对象的实例方法</h4>
<pre><code class="language-java">//Main.java
import java.util.Arrays;

public class Main {
	public static void main(String[] args) {
		String[] strings = {&quot;Jack&quot;, &quot;james&quot;, &quot;Apple&quot;, &quot;abort&quot;};
		Arrays.sort(strings, (s1,s2) -&gt; s1.compareToIgnoreCase(s2));
		System.out.println(Arrays.toString(strings));
		Arrays.sort(strings, String::compareToIgnoreCase);
		System.out.println(Arrays.toString(strings));
	}
}
</code></pre>
<figure data-type="image" tabindex="51"><img src="https://cdn.jsdelivr.net/gh/buffoon-j/images/image-20220907171331390.png" alt="image-20220907171331390" loading="lazy"></figure>
<h4 id="引用构造方法">引用构造方法</h4>
<pre><code class="language-java">//Testable.java
public interface Testable {
	Object test(int v);
}
</code></pre>
<pre><code class="language-java">//Person.java
public class Person {
	public Person(int age) {
		System.out.println(&quot;Person - &quot; + age);
	}
}
</code></pre>
<pre><code class="language-java">//Main.java
public class Main {
	public static void main(String[] args) {
		Testable t1 = v -&gt; new Person(v);
		System.out.println(t1.test(18));
		Testable t2 = Person::new;
		System.out.println(t2.test(18));
	}
}
</code></pre>
<figure data-type="image" tabindex="52"><img src="https://cdn.jsdelivr.net/gh/buffoon-j/images/image-20220907172849941.png" alt="image-20220907172849941" loading="lazy"></figure>
<h4 id="引用当前类中定义的实例方法">引用当前类中定义的实例方法</h4>
<pre><code class="language-java">//Testable.java
public interface Testable {
	void test(int v);
}
</code></pre>
<pre><code class="language-java">//Person.java
public class Person {
	public void setAge(int age) {
		System.out.println(&quot;setAge - &quot; + age);
	}
	public void show() {
		Testable t1 = v -&gt; setAge(v);
		t1.test(10);
		
		Testable t2 = this::setAge;
		t2.test(10);
	}
}
</code></pre>
<pre><code class="language-java">//Main.java
public class Main {
	public static void main(String[] args) {
		new Person().show();
	}
}
</code></pre>
<figure data-type="image" tabindex="53"><img src="https://cdn.jsdelivr.net/gh/buffoon-j/images/image-20220907173626290.png" alt="image-20220907173626290" loading="lazy"></figure>
<h4 id="引用父类中定义的实例方法">引用父类中定义的实例方法</h4>
<pre><code class="language-java">//Testable.java
public interface Testable {
	void test(int v);
}
</code></pre>
<pre><code class="language-java">//Person.java
public class Person {
	public void setAge(int age) {
		System.out.println(&quot;Person - setAge - &quot; + age);
	}
}
</code></pre>
<pre><code class="language-java">//Student.java
public class Student extends Person {
	@Override
	public void setAge(int age) {
		System.out.println(&quot;Student - setAge - &quot; + age);
	}
	public void show() {
		Testable t1 = v -&gt; super.setAge(v);
		t1.test(10);
		
		Testable t2 = super::setAge;
		t2.test(10);
	}
}
</code></pre>
<pre><code class="language-java">//Main.java
public class Main {
	public static void main(String[] args) {
		new Student().show();
	}
}
</code></pre>
<figure data-type="image" tabindex="54"><img src="https://cdn.jsdelivr.net/gh/buffoon-j/images/image-20220907174229310.png" alt="image-20220907174229310" loading="lazy"></figure>

          <div class="toc-container"><ul class="markdownIt-TOC">
<li><a href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1">面向对象</a>
<ul>
<li><a href="#%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA">类的定义、对象的创建</a></li>
<li><a href="#%E5%AF%B9%E8%B1%A1%E4%B8%8E%E6%95%B0%E7%BB%84%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90">对象与数组的内存分析</a>
<ul>
<li><a href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98">对象的内存</a></li>
<li><a href="#%E5%A4%8D%E6%9D%82%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98">复杂对象的内存</a></li>
<li><a href="#%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84%E7%9A%84%E5%86%85%E5%AD%98">对象数组的内存</a></li>
</ul>
</li>
<li><a href="#%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%88%92%E5%88%86">内存区域划分</a></li>
<li><a href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95">构造方法</a>
<ul>
<li><a href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-2">构造方法</a></li>
<li><a href="#this"><code>this</code></a></li>
<li><a href="#%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95">默认构造方法</a></li>
</ul>
</li>
<li><a href="#%E5%8C%85package">包（package）</a>
<ul>
<li><a href="#%E5%8C%85">包</a></li>
<li><a href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E4%B8%80%E4%B8%AA%E7%B1%BB">如何使用一个类</a></li>
</ul>
</li>
<li><a href="#%E7%BB%A7%E6%89%BF">继承</a>
<ul>
<li><a href="#%E7%BB%A7%E6%89%BF-2">继承</a></li>
<li><a href="#object%E7%B1%BB"><code>Object</code>类</a></li>
<li><a href="#%E5%90%8C%E5%90%8D%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F">同名成员变量</a></li>
<li><a href="#%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E5%86%99">方法的重写</a></li>
<li><a href="#super"><code>super</code></a></li>
<li><a href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%BB%86%E8%8A%82">构造方法细节</a></li>
</ul>
</li>
<li><a href="#%E6%B3%A8%E8%A7%A3">注解</a></li>
<li><a href="#%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6">访问控制</a></li>
<li><a href="#%E5%B0%81%E8%A3%85">封装</a></li>
<li><a href="#tostring%E6%96%B9%E6%B3%95"><code>toString</code>方法</a></li>
<li><a href="#static"><code>Static</code></a>
<ul>
<li><a href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F">成员变量</a></li>
<li><a href="#%E6%96%B9%E6%B3%95">方法</a></li>
<li><a href="#%E6%B3%A8%E6%84%8F">注意</a></li>
<li><a href="#%E9%9D%99%E6%80%81%E5%AF%BC%E5%85%A5">静态导入</a></li>
<li><a href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96">成员变量初始化</a></li>
<li><a href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F">单例模式</a></li>
</ul>
</li>
<li><a href="#final_%E5%B8%B8%E9%87%8F"><code>final</code>_常量</a>
<ul>
<li><a href="#final"><code>final</code></a></li>
<li><a href="#%E5%B8%B8%E9%87%8F">常量</a></li>
</ul>
</li>
<li><a href="#%E5%B5%8C%E5%A5%97%E7%B1%BB_%E5%B1%80%E9%83%A8%E7%B1%BB">嵌套类_局部类</a>
<ul>
<li><a href="#%E5%B5%8C%E5%A5%97%E7%B1%BBnested-class">嵌套类（Nested Class）</a>
<ul>
<li><a href="#%E5%86%85%E9%83%A8%E7%B1%BBinner-class">内部类（Inner Class）</a></li>
<li><a href="#%E9%9D%99%E6%80%81%E5%B5%8C%E5%A5%97%E7%B1%BBstatic-nested-class">静态嵌套类（Static Nested Class）</a></li>
<li><a href="#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BD%BF%E7%94%A8%E5%B5%8C%E5%A5%97%E7%B1%BB">什么情况下使用嵌套类？</a></li>
</ul>
</li>
<li><a href="#%E5%B1%80%E9%83%A8%E7%B1%BBlocal-class">局部类（Local Class）</a></li>
</ul>
</li>
<li><a href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB_%E6%8E%A5%E5%8F%A3">抽象类_接口</a>
<ul>
<li><a href="#%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95abstract-method">抽象方法（Abstract Method）</a></li>
<li><a href="#%E6%8A%BD%E8%B1%A1%E7%B1%BBabstract-class">抽象类（Abstract Class）</a></li>
<li><a href="#%E6%8E%A5%E5%8F%A3interface">接口（Interface）</a>
<ul>
<li><a href="#%E6%B3%A8%E6%84%8F-2">注意</a></li>
<li><a href="#%E6%8E%A5%E5%8F%A3%E7%BB%86%E8%8A%82">接口细节</a></li>
<li><a href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8D%87%E7%BA%A7%E9%97%AE%E9%A2%98">接口的升级问题</a>
<ul>
<li><a href="#%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95default-method">默认方法(Default Method)</a></li>
<li><a href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95static-method">静态方法(Static Method)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3%E5%AF%B9%E6%AF%94">抽象类与接口对比</a></li>
</ul>
</li>
<li><a href="#%E5%A4%9A%E6%80%81polymorphism">多态（Polymorphism）</a>
<ul>
<li><a href="#%E7%B1%BB%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E7%BB%86%E8%8A%82">类方法调用细节</a></li>
<li><a href="#%E7%88%B6%E7%B1%BB%E5%A3%B0%E6%98%8E%E5%AD%90%E7%B1%BB%E5%AE%9E%E4%BE%8B%E5%8C%96%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E7%9A%84%E8%AE%BF%E9%97%AE%E7%BB%86%E8%8A%82">父类声明子类实例化（成员变量的访问细节）</a></li>
<li><a href="#instanceof">instanceof</a></li>
</ul>
</li>
<li><a href="#%E5%8C%BF%E5%90%8D%E7%B1%BBanonymous-class">匿名类（Anonymous Class）</a>
<ul>
<li><a href="#%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F">使用注意</a></li>
<li><a href="#%E5%B8%B8%E8%A7%81%E7%94%A8%E9%80%94%E5%8F%8A%E4%BC%AA%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B">常见用途及伪代码示例</a></li>
<li><a href="#%E6%8E%92%E5%BA%8F">排序</a>
<ul>
<li><a href="#comparable-vs-comparator">Comparable vs Comparator</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#lambda-expression">Lambda Expression</a>
<ul>
<li><a href="#%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8method-reference">方法引用（Method Reference）</a>
<ul>
<li><a href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E6%96%B9%E6%B3%95">引用类方法</a></li>
<li><a href="#%E5%BC%95%E7%94%A8%E7%89%B9%E5%AE%9A%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95">引用特定对象实例方法</a></li>
<li><a href="#%E5%BC%95%E7%94%A8%E7%89%B9%E5%AE%9A%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BB%BB%E6%84%8F%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95">引用特定类型的任意对象的实例方法</a></li>
<li><a href="#%E5%BC%95%E7%94%A8%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95">引用构造方法</a></li>
<li><a href="#%E5%BC%95%E7%94%A8%E5%BD%93%E5%89%8D%E7%B1%BB%E4%B8%AD%E5%AE%9A%E4%B9%89%E7%9A%84%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95">引用当前类中定义的实例方法</a></li>
<li><a href="#%E5%BC%95%E7%94%A8%E7%88%B6%E7%B1%BB%E4%B8%AD%E5%AE%9A%E4%B9%89%E7%9A%84%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95">引用父类中定义的实例方法</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
          
          <hr />
          <p class="next-post">下一篇：
            <a href="https://bujreny.github.io/post/liu-ge-jian-dan-chang-jian-de-ji-chu-ti/">
              <span class="post-title">
                六个简单常见的基础题&rarr;
              </span>
            </a>
          </p>
          
          <div class="comment" style="text-align: center;">
            
            <span id="/post/2mian-xiang-dui-xiang/" class="leancloud_visitors"
              data-flag-title="2.面向对象">
              <em class="post-meta-item-text">阅读量 </em>
              <i class="leancloud-visitors-count">loading...</i>
            </span>
            

            
            
            <script src='https://cdn.jsdelivr.net/gh/HCLonely/Valine@latest/dist/Valine.min.js'></script>
<style>
	div#vcomments{
		width:100%;
		max-width: 1000px;
		padding: 2.5%
	}
</style>


	<div id="vcomments" class="card-content"></div>

<script>
	new Valine({
		el: '#vcomments',
		appId: 'MUWPVbUhlsflIPTycp1VNETB-gzGzoHsz',
		appKey: 'xIyXvk2GGYSQYhGriyDiO5qv',
		avatar: 'monsterid',
		pageSize: 5,
		recordIp: true,
		placeholder: 'Just Go Go',
		visitor: true,
	});
</script>

            
          </div>
        </div>
      </div>
  </article>
  <!-- Footer -->
  <footer>
    <div class="container">
      <div class="row">
        <div class="col-lg-8 col-md-10 mx-auto">
          <ul class="list-inline text-center">
            
            
            <li class="list-inline-item">
              <a href="https://github.com/buffoon-j" target="_blank">
                <span class="fa-stack fa-lg">
                  <i class="fas fa-circle fa-stack-2x"></i>
                  <i class="fab fa-github fa-stack-1x fa-inverse"></i>
                </span>
              </a>
            </li>
            
              
            
              
            
              
            
              
            
              
            
              
            
              
              <!-- <li class="list-inline-item">
              <a href="https://bujreny.github.io/atom.xml" target="_blank">
                <span class="fa-stack fa-lg">
                  <i class="fas fa-circle fa-stack-2x"></i>
                  <i class="fas fa-rss fa-stack-1x fa-inverse"></i>
                </span>
              </a>
              </li> -->
          </ul>
          <p class="copyright text-muted">Copyright &copy;<span>Buffoon&#39;s world</span><br><a href="https://github.com/getgridea/gridea" class="Themeinfo">Powered by Gridea</a></p>
        </div>
      </div>
    </div>
   </footer>
  <!-- Bootstrap core JavaScript -->
  <script src="https://cdn.bootcss.com/twitter-bootstrap/4.3.1/js/bootstrap.bundle.min.js"></script>
  <!-- <script src="https://bujreny.github.io/media/scripts/bootstrap.bundle.min.js"></script> -->
  <!-- Bootstrap core JavaScript -->
  <script src="https://cdn.jsdelivr.net/gh/Alanrk/clean-cdn@1.0/scripts/clean-blog.min.js"></script>
  <!-- <script src="https://bujreny.github.io/media/scripts/clean-blog.min.js"></script> -->
  <script src="//instant.page/3.0.0" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script>
  <style type="text/css">a.back_to_top{text-decoration:none;position:fixed;bottom:40px;right:30px;background:#f0f0f0;height:40px;width:40px;border-radius:50%;line-height:36px;font-size:18px;text-align:center;transition-duration:.5s;transition-propety:background-color;display:none}a.back_to_top span{color:#888}a.back_to_top:hover{cursor:pointer;background:#dfdfdf}a.back_to_top:hover span{color:#555}@media print,screen and(max-width:580px){.back_to_top{display:none!important}}</style>
<a id="back_to_top" href="#" class="back_to_top">
  <span>▲</span></a>
<script>$(document).ready((function(_this) {
    return function() {
      var bt;
      bt = $('#back_to_top');
      if ($(document).width() > 480) {
        $(window).scroll(function() {
          var st;
          st = $(window).scrollTop();
          if (st > 30) {
            return bt.css('display', 'block')
          } else {
            return bt.css('display', 'none')
          }
        });
        return bt.click(function() {
          $('body,html').animate({
            scrollTop: 0
          },
          800);
          return false
        })
      }
    }
  })(this));</script>
  
  <script src="https://bujreny.github.io/media/scripts/tocScript.js"></script>
</body>

</html>