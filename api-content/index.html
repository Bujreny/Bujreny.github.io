{"posts":[{"title":"2.面向对象","content":"面向对象 类的定义、对象的创建 示例： // Dog.java public class Dog { // 成员变量 public int age; public double weight; // 方法 public void run() { System.out.println(age + &quot;_&quot; + weight + &quot;_run&quot;); } public void eat(String food) { System.out.println(age + &quot;_&quot; + weight + &quot;_eat_&quot; + food); } } // Main.java public class Main { public static void main(String[] args) { Dog dog = new Dog(); dog.age = 20; dog.weight = 5.6; dog.run(); dog.eat(&quot;apple&quot;); } } 成员变量（Member Variable）也叫字段（Field） 对象与数组的内存分析 对象的内存 Java中所有对象都是new出来的，所有对象的内存都是在堆空间。堆空间里面存的是成员变量，没有方法。 示例： Java运行时环境有个垃圾回收器（garbage collector, 简称GC），会自动回收不在使用的内存，即当一个对象没有任何引用时，会被CG回收掉内存。 复杂对象的内存 示例： // Person.java public class Person { public int age; public Dog dog; } // Cat.java public class Dog { public int price; } // Main.java public class Main { public static void main(String[] args) { Dog dog = new Dog(); cat.price = 100; Person person = new Person(); person.age = 20; person.dog = dog; } } 对象数组的内存 示例： 内存区域划分 Java虚拟机在执行Java程序时会将内存划分为若干个不同的区域数据，主要有： 数据区域名称 作用 PC寄存器（Program Counter Register） 存储 Java 虚拟机正在执行的字节码指令的地址 Java虚拟机栈（Java Virtual Machine Stack） 存储栈帧 堆（Heap） 存储 GC 所管理的各种对象 方法区（Method Area） 存储每一个类的结构信息（比如字段和方法信息、构造方法和普通方法的字节码等） 本地方法栈（Native MEthod Stack） 用来支持native方法的调用（比如用C编写的方法） 构造方法 构造方法 构造方法，也叫构造器，能够更方便的穿件一个对象。 构造方法有以下特点： 方法名必须和类名一样 没有返回值类型 可以重载 示例： //Dog.java public class Dog { public int age; public double weight; // 构造方法 public Dog() {} public Dog(int age) { this.age = age; } public Dog(int age, double weight) { this.age = age; this.weight = weight; } } //Main.java public class Main { public static void main(String[] args) { Dog dog1 = new Dog(); Dog dog2 = new Dog(18); Dog dog3 = new Dog(20, 6.66); } } 建议：每个Java类都提供无参构造方法。 this this是一个指向当前对象的引用，常见用途有： 访问当前类中定义的成员变量 调用当前类中定义的方法（包括构造方法） 示例： //Cat.java public class Cat { public String name; public int age; public int price; public Cat(String name, int age,int price) { this.name = name; this.age = age; this.price = price; } public Cat(String name) { this(name, 0, 0); // 下面这两行调用run方法都没有报错，所以有时候this可以不用写 this.run(); run(); } public void run() { System.out.println(&quot;Running!&quot;); } } this的本质是一个隐藏的、位置靠前的方法参数。 示例： //Dog.java public class Dog { public int price; public void run() { System.out.println(price + &quot;_run&quot;); } public void eat() { System.out.println(price + &quot;_eat&quot;); } } //Main.java public class Main { public static void main(String[] args) { Dog dog1 = new Dog(); dog1.price = 100; dog1.run(); dog1.eat(); Dog dog2 = new Dog(); dog2.price = 200; dog2.run(); dog2.eat(); } } 在内存区域划分相关内容可以了解到，方法并没有和属性一起存储到栈帧中，而是存储在方法区的类的结构信息中。所以每个类只有这一份方法，那么两个对象调用一个方法，在目测没有传进去任何参数的情况下输出了不同的内容。其原因是this作为一个隐藏的、位置靠前的参数，在调用方法的时候把对象本身传了进去，所以可以做到两个Dog对象调用了方法区的同一份方法，却输出了不同的结果。 注意（可以看this的第一个示例）： 只能在构造方法中使用this调用其他构造方法 如果在构造方法中调用了其它构造方法，构造方法调用构造方法的语句必须是语句中的第一条。 默认构造方法 如果一个类没有自定义构造方法，编译器会自动为它提供无参的默认构造方法。 **注意：**一旦自定义了构造方法，默认构造方法就不再存在。这一点可以利用IDEA的反编译功能打开编译的字节码文件（.class）和自己写的代码(.java)进行比对。 包（package） 包 Java中的包就是其他编程语言中的命名空间，包的本质是文件夹（创建包后在本地资源管理器查看可以发现），常见作用： 将不同的类进行组织管理、访问控制 解决命名冲突 命名建议： 为了保证包的唯一性，一般包名都是以公司域名的倒写开头，例如：com.orangestudio.* 全部小写（可以避免与某些类名或者接口名冲突） **注意：**类的第一句代码必须使用package声明自己属于哪个包。 示例： 如果公司域名有非法字符，建议添加下划线（_）来使包名合法化。 示例： 域名 软件包名称前缀 my-name.example.org org.example.my_name example.int int_.example 123name.example,com com.example._123name 如何使用一个类 要想正常使用一个类，必须要知道这个类的具体位置（在哪个包），有三种常见方式来使用一个类： 使用类的全名 com.orangestudio.study.Dog dog = new com.orangestudio.study.Dog(); 使用import导入指定类名 import com.orangestudio.study.Dog; public class Main { public static void main(String[] args) { Dog dog = new Dog(); } } 使用import导入整个包的所有类 import com.orangestudio.study.*; public class Main { public static void main(String[] args) { Dog dog = new Dog(); } } 注意： 为了方便，java编译器会为每个源文件自动导入两个包 import java.lang.*（这个包提供了Java开发中最常用的一些类型） import 源文件所在包 .* import aa.bb.* 仅仅是导入了直接存放在aa.bb包中的一些类型 并不包含bb包下其它包内的类型 继承 继承 示例： // Person.java public class Person { public int age; public void run() { System.out.println(age + &quot;_run&quot;); } } // Student.java public class Student extends Person { public int no; public void study() { System.out.println(age + &quot;_&quot; + &quot;_study&quot;); } } // Main.java public class Main { public static void main(String[] args) { Person person = new Person(); person.age = 15; person.run(); Student student = new Student(); student.age = 20; student.no = 1; student.run(); student.study(); } } 上面代码中两个对象在内存中的状态如图所示： 对象在堆内存储的时候，会把最顶级的父类成员变量放在最上面，然后依次放下一级的成员变量，最后放自己的成员变量。 Object类 任何类最终都继承自java.lang.Object类，一般称他为基类。当你新建一个类的时候，这个类就会默认继承自Object类. 同名成员变量 子类可以定义跟父类同名的成员变量（不推荐）。 示例： // Person.java public class Person { public int age = 1; } // Student.java public class Student extends Person { public int age = 2; public void show() { System.out.println(age); System.out.println(this.age); System.out.println(super.age); } } // Main.java public class Main { public static void main(String[] args) { Student student = new Student(); student.show(); } } 方法的重写 重写：子类的实例方法签名与父类一样，也叫做覆盖、复写。 示例： // Animal.java public class Animal { public void speak() { System.out.println(&quot;Animal - speak&quot;); } public void run() { System.out.println(&quot;Animal - run&quot;); } } // Dog.java public class Dog extends Animal { @Override public void speak() { super.speak(); run(); this.run(); super.run(); System.out.println(&quot;Dog - speak&quot;); } @Override public void run() { System.out.println(&quot;Dog - run&quot;); } } // Main.java public class Main { public static void main(String[] args) { new Dog().speak(); } } **注意：**子类的实例方法必须与父类的实例方法签名一样，签名不一样不属于重写（方法签名包括方法名和参数类型），可以理解为重载。 注意： 子类override的方法权限必须&gt;=父类的方法权限 如果子类override的方法返回值类型是A，父类的方法返回值类型是B，那么A==B或者，A是B的子类。 子类的类方法签名和父类一样，不能称之为重写。 super 常见用途： 访问父类定义的成员变量 调用父类中定义的方法（包括构造方法） 示例（与方法的重写中示例基本一致）： // Animal.java public class Animal { public Animal() { System.out.println(&quot;Animal - constuctor&quot;); } public void speak() { System.out.println(&quot;Animal - speak&quot;); } public void run() { System.out.println(&quot;Animal - run&quot;); } } // Dog.java public class Dog extends Animal { public Dog() { super(); } @Override public void speak() { super.speak(); run(); this.run(); super.run(); System.out.println(&quot;Dog - speak&quot;); } @Override public void run() { System.out.println(&quot;Dog - run&quot;); } } // Main.java public class Main { public static void main(String[] args) { new Dog().speak(); } } 构造方法细节 子类的构造方法必须先调用父类的构造方法，然后再执行后面的代码 **注意：**如果子类的构造方法没有显式调用父类的构造方法，编译器会自动调用父类无参的构造方法（若此时父类没有无参的构造方法，编译器将报错）。 注解 常用注解： @override告诉编译器这是一个重写后的方法。重写方法时，如果你的方法签名和父类方法不一样，会报错。 @SuppressWarnings(&quot;警告类别&quot;)让编译器不生成警告信息。可以放在方法前（类前）来使方法内（类内）的所有这个类型警告都消失。使用方式： @superWarnings({&quot;rawtypes&quot;, &quot;unused&quot;})多个警告信息时，里面传入的是一个字符数组 @SuppressWarnings(&quot;unused&quot;)单个警告 示例： 访问控制 Java中有四个级别访问权限，从高到低： public：在任何地方都可见。 protected：仅在自己的包中、自己的子类中可见。 无修饰符（package-private、default、friendly)：仅在自己的包中可见。 private：仅在自己的类中可见。 如图所示： 同一类 同一包：库单元 不同包子类 不同包非子类（anywhere） public 可以访问 可以访问 可以访问 可以访问 protected 可以访问 可以访问 可以访问 无修饰符 可以访问 可以访问 private 可以访问 注意事项： 四个访问权限都可以修饰类的成员，比如成员变量、方法、嵌套类（Nested Class）等。 只有public和无修饰符可以修饰顶级类（Top-level Class，定义在最外面的类）。 上述四个访问权限不可以修饰局部类（Local Class）、局部变量。 一个Java源文件中可以定义多个顶级类，public顶级类的名字必须和文件名一样。 封装 为成员变量private化提供public的getter、setter。 示例： public class Person { private int age; private String name; public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } } 子类对象的内存中，包含父类中定义的private成员变量。可以通过getter、setter来对private成员变量进行访问。 toString方法 当打印一个对象时，会自动调用对象的toString方法，并将返回的字符串打印出来。 toString代码如下： 所以我们可以通过重写toString方法来达到打印对象时输出自己要打印的东西 Static static常用来修饰类的成员：成员变量、方法、嵌套类 成员变量 被static修饰：类变量、静态变量、静态字段，特点： 在程序运行过程中只占用一份固定的内存（存储在方法区） 可以通过实例、类访问 没有被static修饰：实例变量，特点： 在每个实例内部都有一份内存 只能通过实例访问，不可以通过类访问 方法 被static修饰：类方法、静态方法，特点： 可以通过实例、类访问 内部不可以用this 可以直接访问类变量、类方法 不可以直接访问实例变量、实例方法 没有被static修饰：实例方法，特点： 只能通过实例访问，不可以通过类访问 内部可以使用this 可以直接访问实例变量、实例方法 可以直接访问类变量、类方法 注意 不推荐试听实例访问类变量、类方法 在同一个类中，不能有同名的实例变量和类变量，不能有相同签名的实例方法和类方法 静态导入 使用静态导入后，可以省略类名访问静态成员（成员变量、方法、嵌套类）。 示例： 各文件位置情况如下： // Person.java package com.orangestudio.study; public class Person { public static int age = 1; public static void show() { System.out.println(&quot;age is &quot; + age); } public static class Foot { public void run() { System.out.println(&quot;run&quot;); } } } // Main.java package com.orangestudio; import static com.orangestudio.study.Person.*; public class Main { public static void main(String[] args) { System.out.println(age); show(); Foot foot = new Foot(); foot.run(); } } 常见使用： import static java.lang.Math.PI; public class Main { public static void main(String[] args) { System.out.println(2 * PI * 10); System.out.println(2 * PI * 20); } } 注意： 正常使用静态导入，可以消除一些重复的类名，提高代码可读性。 过度使用静态导入，会分不清静态成员是在哪个类中定义的，所以要谨慎使用静态导入。 成员变量初始化 编译器会自动为未初始化的成员变量设置初始值。 手动给实例变量提供初始值： // 在声明中 public int age = 10; // 在构造方法中 public Main() { age = 10; } // 在初始化块（初始化代码块、匿名代码块）中 { age = 10; } **初始化块(初始化代码块、匿名代码块)：**编译器会将初始化块复制到每个构造方法的头部，即每创建一个实例对象，就会执行一次初始化块。但在实际操作中，更多地会把公共的初始代码放在参数最多的构造方法里，然后其他构造方法调用这个参数最多的构造方法。 手动给类变量提供初始值： // 在声明中 public static int count = 10; // 在静态初始化块（静态代码块）中 static { count = 10; } 在静态代码块中： 当一个类被初始化的时候执行静态代码块，且只执行一次。 当第一个类被主动使用时，JVM会对类进行初始化。 初始化代码块与静态初始化代码块 一个类中可以有多个（静态）初始化块，按照在源码中出现的顺序被执行，静态初始化块要比初始化块先执行，具体示例及原因见：之前写的匿名代码块与static代码块。 如果一个类有父类，那么对这个类进行实例化操作的时候，会先对其父类进行初始化，然后对其进行初始化，然后执行其父类构造方法，然后执行其本身的构造方法，示例如下： 示例： // Person.java public class Person { static { System.out.println(&quot;Person-----静态初始化块&quot;); } { System.out.println(&quot;Person-----初始化块&quot;); } public Person() { System.out.println(&quot;Person-----构造方法&quot;); } } // Student.java public class Student extends Person { static { System.out.println(&quot;Student-----静态初始化块&quot;); } { System.out.println(&quot;Student-----初始化块&quot;); } public Student() { System.out.println(&quot;Student-----构造方法&quot;); } } // Main.java public class Main { public static void main(String[] args) { Student s1 = new Student(); System.out.println(&quot;====================&quot;); Student s2 = new Student(); } } 单例模式 如果一个类设计成单例模式，单么在程序运行过程中，这个类只能创建一个实例。一般需要具备的条件： 私有的静态实例变量 构造方法私有化 公共的静态方法，返回唯一的实例 实例： // Rocket.java // 饿汉式单例模式 public class Rocket { // 私有的静态的实例变量 private static Rocket instance = new Rocket(); // 构造方法私有化 private Rocket() {} // 公共的静态方法，返回唯一的实例 public static Rocket getInstance() { return instance; } } // Main.java public class Main { public static void main(String[] args) { Rocket r1 = Rocket.getInstance(); Rocket r2 = Rocket.getInstance(); Person p1 = new Person(); Person p2 = new Person(); int n1 = 10; int n2 = 20; int n3 = 20; System.out.println(r1 == r2); System.out.println(p1 == p2); System.out.println(n1 == n2); System.out.println(n2 == n3); } } 补充：Java中==比较的是两个变量的值，基本类型在Java虚拟机栈中存放的是其表示的值，引用类型在Java虚拟机栈中存放的是对象在堆中的地址值。所以==比较基本数据类型，是比较其数值；比较引用类型，则是比较其是不是一个对象。 另一种方式： // 懒汉式单例模式,存在线程安全问题 public class Rocket { private static Rocket instance = null; private Rocket() {}; public static Rocket getInstance() { if (instance == null) { instance = new Rocket(); } return instance; } } final_常量 final 被final修饰的类：不能被子类化，不能被继承。 被final修饰的方法：不能被重写。 被final修饰的变量：只能进行一次赋值。如果修饰成员变量，对象创建完，被final修饰的成员变量必须有值。 常量 常量的写法： public static final double PI = 3.141592653589; private static final int NOT_FOUND = -1; 如果将基本类型或字符串定义为常量，并且在编译时就能确定值，编译器会使用常量值代替各处的常量名（类似于C语言的宏替换），这种常量称为编译时常量（compile-time constant）。 嵌套类_局部类 嵌套类（Nested Class） 嵌套类（Nested Class）是定义在另一个类中的类，在嵌套类外层的类叫外部类（Outer Class），最外层的外部类叫顶级类（Top-level Class）。示例： public class OuterClass { // 静态嵌套类 static class StaticNestedClass { } // 非静态嵌套类（内部类） class InnerClass { } } 内部类（Inner Class） 嵌套类：没有被static修饰的嵌套类，非静态嵌套类。 注意： 跟实例变量、实例方法一样，内部类与外部类实例相关联。必须先创建外部类实例，然后利用外部类实例创建内部类实例；内部类不能定义除编译时常量以外的任何static成员。 内部类可以直接访问外部类中的所有成员（即使被声明为private）。 外部类可以直接访问内部类实例的成员变量、方法（即使被声明为private）。 内部类与外部类内存分析： // Person.java public class Person { private int age; public class Hand { private int weight; } } // Main.java public class Main { public static void main(String[] args) { Person p1 = new Person(); Hand h1 = p1.new Hand(); Person p2 = new Person(); Hand h2Hand = p2.new Hand(); } } 程序内存分析如下： 内部类示例： // Company.java public class Company { private String name; public Company(String name) { this.name = name; } public void fire(Employee e) { System.out.println(name + &quot; fire &quot; + e.no); } public class Employee { private int no; public Employee(int no) { this.no = no; } public void show() { System.out.println(name + &quot; : &quot; + no); } } } // Main.java public class Main { public static void main(String[] args) { Company company = new Company(&quot;Orange&quot;); Employee employee = company.new Employee(1); employee.show(); company.fire(employee); } } 内部类细节： // OuterClass.java public class OuterClass { private int x= 1; public class InnerClass { private int x = 2; public void show() { System.out.println(x); System.out.println(this.x); System.out.println(OuterClass.this.x); } } } // Main.java public class Main { public static void main(String[] args) { new OuterClass().new InnerClass().show(); } } 外部类与内部类出现同名的成员变量时，可以通过外部类名.this.成员变量名访问外部类的成员变量。 静态嵌套类（Static Nested Class） 静态嵌套类：被static修饰的嵌套类。 注意： 嵌套类在行为上就是一个顶级类，只是定义的代码写在了另一个类中。 对于一般的顶级类，静态嵌套类多了一些特殊的权限，例如可以直接访问外部类中的成员（即使被声明为private）。 示例： // Person.java public class Person { public static class Car {} public class House {} } // Main.java public class Main { public static void main(String[] args) { Person.Car car = new Person.Car(); Person.House house = new Person.House(); } } 报错如下： 什么情况下使用嵌套类？ 如果类A只用在类C内部，可以考虑将类A嵌套到类C中。 封装性更好 程序包更加简化 增强可读性、维护性 示例： // Person.java public class Person { public void run() { Dog dog = new Dog(); } public void walk() { Dog dog = new Dog(); } private class Dog{} } 如果类A需要经常访问类C的非公共成员，可以考虑将类A嵌套到类C中。 另外可以根据需要将类A隐藏起来，不对外暴露。 如果需要经常访问非公共的实例成员，设计成内部类（非静态嵌套类），否则设计成静态嵌套类（能静态尽量静态）。 如果必须先有C实例，才能创建A实例，那么可以将A设计为C的内部类。 局部类（Local Class） 局部类：定义在代码中的类（可以定义在方法中、for循环中、if语句中等） 注意： 局部类不能定义除编译时常量以外的任何static成员。 局部类只能访问final或者有效final的局部变量。 从Java8开始，如果局部变量没有进行第二次赋值，就认定是有效final。 局部类可以直接访问外部类中的所有成员（即使被声明为private）。 局部类只有定义在实例相关的代码块中，才能直接访问外部类中的实例变量。 示例： // TestLocalClass.java public class TestLocalClass { private int a = 1; private static int b = 2; private static void test1() {} private void test2() {} public void test3() { int c = 2; class LocalClass { static final int d = 4; void test4() { System.out.println(a + b + c + d); test1(); test2(); } } new LocalClass().test4(); } } // Main.java public class Main { public static void main(String[] args) { new TestLocalClass().test3(); } } 抽象类_接口 抽象方法（Abstract Method） 抽象方法：被abstract修饰的实例方法。 特点： 只有方法声明，没有方法实现（参数列表后面没有大括号，而是分号） 不能是private权限（因为定义抽象方法的目的是让子类去实现） 只能定义在抽象类、接口中 抽象类（Abstract Class） 抽象类：被abstract修饰的类。 特点： 可以定义抽象方法。 不能实例化，但可以自定义构造方法。 子类必须实现抽象父类中的所有抽象方法（除非子类也是一个抽象类）。 可以像非抽象类一样定义成员变量、常量、嵌套类型、初始化块、非抽象方法等。也就是说，抽象类也可以完全不定义抽象方法。 使用场景：抽取子类的公共实现到抽象父类中，要求子类必须单独实现的定义成抽象方法。 示例： // Shape.java public abstract class Shape { protected double area; protected double girth; public double getGrith() { return girth; } public double getArea() { return area; } public void show() { calculate(); System.out.println(area + &quot;_&quot; + girth); } protected abstract void calculate(); } // Rectangle.java public class Rectangle extends Shape { private double width; private double height; public Rectangle(double width, double height) { this.width = width; this.height = height; } @Override protected void calculate() { area = width * height; girth = (width + height) * 2; } } // Circle.java public class Circle extends Shape { private double radius; public Circle(double radius) { this.radius = radius; } @Override protected void calculate() { double half = Math.PI * radius; area = half * radius; girth = half * 2; } } // Main.java public class Main { public static void main(String[] args) { Rectangle rectangle = new Rectangle(10, 20); rectangle.show(); Circle circle = new Circle(10); circle.show(); } } 接口（Interface） API（Application Programming Interface）：应用编程接口，提供给开发者调用的一组功能（无需提供源码）。 Java中的接口：一系列方法声明的集合，用来定义规范、标准。 示例： 实现一个家教接口，家教有学生和老师，具备教孩子编程和足球的能力。实现孩子类有名字，可以进行学习，可以选择家教。 // JiaJiaoAble.java public interface JiaJiaoAble { public abstract void jiaoBianCheng(Child child); public abstract void jiaoZuQiu(Child child); } // Student.java public class Student implements JiaJiaoAble { @Override public void jiaoBianCheng(Child child) { System.out.println(&quot;Student教&quot; + child.getName() + &quot;编程&quot;); } @Override public void jiaoZuQiu(Child child) { System.out.println(&quot;Student教&quot; + child.getName() + &quot;足球&quot;); } } //Teacher.java public class Teacher implements JiaJiaoAble { @Override public void jiaoBianCheng(Child child) { System.out.println(&quot;Teacher教&quot; + child.getName() + &quot;编程&quot;); } @Override public void jiaoZuQiu(Child child) { System.out.println(&quot;Teacher教&quot; + child.getName() + &quot;足球&quot;); } } //Child.java public class Child { private String name; public String getName() { return name; } public void setName(String name) { this.name = name; } private JiaJiaoAble jiaJiao; public void study() { jiaJiao.jiaoBianCheng(this); jiaJiao.jiaoZuQiu(this); } public void setJiaJiao(JiaJiaoAble jiaJiao) { this.jiaJiao = jiaJiao; } public JiaJiaoAble getJiaJiao() { return jiaJiao; } } //Main.java public class Main { public static void main(String[] args) { Child child = new Child(); child.setName(&quot;Buffoon&quot;); child.setJiaJiao(new Student()); child.study(); System.out.println(&quot;--------------------------&quot;); child.setJiaJiao(new Teacher()); child.study(); } } 注意 接口中可以定义：抽象方法、常量、嵌套类型。从java8开始可以定义：默认方法、静态方法（类方法）。 上述定义内容都是隐式public的，因此可以省略public关键字。 从java9开始可以定义private方法 常量可以省略static、final 抽象方法可以省略abstact 不能自定义构造方法、不能定义（静态）初始化块、不能实例化。 接口细节 接口名称可以在任何使用类型的地方使用 一个类可以通过implements关键字实现一个或多个接口 实现接口的类必须实现接口中定义的所有抽象方法，除非它是个抽象类 如果一个类实现的多个接口中有相同的抽象方法，只需要实现此方法一次 extends和implements可以一起使用，implements必须写在extends后面 当父类、接口中方法签名一样时，那么返回值类型也必须一样 一个接口可以通过extends关键字继承一个或多个接口 当多个父接口中的方法签名一样时，那么返回值类型也必须一样 接口的升级问题 如果需要接口升级（比如增加新的抽象方法），会导致大幅代码改动，以前实现接口的类都得改动。拖箱不在改动以前类的前提下进行接口升级，从java8开始，有两种方案：默认方法(Default Method)、静态方法(Static Method) 默认方法(Default Method) 用default修饰默认方法，默认方法只能是实例方法。 示例： // JiaJiaoAble.java public interface JiaJiaoAble { void jiaoBianCheng(Child child); default void jiaoZuQiu(Child child) { System.out.println(&quot;JiaJiaoAble-----jiaoZuQiu&quot;); } } //Student.java public class Student implements JiaJiaoAble { @Override public void jiaoBianCheng(Child child) { System.out.println(&quot;Student-----jiaoBianCheng&quot;); } } //Teacher.java public class Teacher implements JiaJiaoAble { @Override public void jiaoBianCheng(Child child) { System.out.println(&quot;Teacher-----jiaoBianCheng&quot;); } @Override public void jiaoZuQiu(Child child) { System.out.println(&quot;Teacher-----jiaoZuQiu&quot;); } } //Child.java public class Child { private String name; public String getName() { return name; } public void setName(String name) { this.name = name; } private JiaJiaoAble jiaJiao; public void study() { jiaJiao.jiaoBianCheng(this); jiaJiao.jiaoZuQiu(this); } public void setJiaJiao(JiaJiaoAble jiaJiao) { this.jiaJiao = jiaJiao; } public JiaJiaoAble getJiaJiao() { return jiaJiao; } } //Main.java public class Main { public static void main(String[] args) { Child child = new Child(); child.setName(&quot;Buffoon&quot;); child.setJiaJiao(new Student()); child.study(); System.out.println(&quot;--------------------------&quot;); child.setJiaJiao(new Teacher()); child.study(); } } 使用： 一个类实现的接口中有默认方法时，这个类可以 沿用接口的默认实现 重新定义默认方法，覆盖默认方法的实现 重新声明默认方法，将默认方法声明为抽象方法（此类必须是抽象类） 当一个接口继承的父接口中有默认方法时，这个接口可以： 沿用接口的默认实现 重新定义默认方法，覆盖默认方法的实现 重新声明默认方法，将默认方法声明为抽象方法 细节： 如果父类定义的非抽象方法与接口的默认方法相同时，最终将调用父类的方法 如果父类定义的抽象方法与接口的默认方法相同时，要求子类实现此抽象方法。可以通过super关键字调用接口的默认方法。接口名.super.方法名 如果（父）接口定义的默认方法与其他（父）接口定义的方法相同时，要求子类型实现此默认方法。 静态方法(Static Method) 接口中定义的静态方法只能通过接口名调用，不能被继承。 示例： //Runnable.java public interface Runnable { static void run(String name) { System.out.println(&quot;Runnable - run - &quot; + name); } } //Main.java public class Main { public static void main(String[] args) { Runnable.run(&quot;小明&quot;); } } 抽象类与接口对比 区别： 抽象类：A extends B，A是B 接口：A implements B, A会 B的行为 何时选择抽象类： 在紧密相关的类之间共享代码 需要除public之外的访问权限 需要定义实例变量、非final的静态变量 何时选择接口： 不相关的类实现相同的方法 知识定义行为，不关心具体是谁实现了行为 想实现类型的多重继承 多态（Polymorphism） 多态通俗的来说是具有多种形态，具体的来说是统一操作作用于不用的对象，产生不同的执行结果。 体现： 父类（接口）类型指向子类对象 调用子类重写方法 JVM会根据引用变量指向的具体对象来调用对应的方法。这个行为叫做虚方法调用（virtual method invocation）,类似于C++中的虚函数调用。 示例1： //Animal.java public class Animal { public void speak() { System.out.println(&quot;Animal-----speak&quot;); } } //Dog.java public class Dog extends Animal { @Override public void speak() { System.out.println(&quot;Dog-----wangwang&quot;); } } //Cat.java public class Cat extends Animal { @Override public void speak() { System.out.println(&quot;Cat-----miaomiao&quot;); } } //Main.java public class Main { public static void main(String[] args) { speak(new Dog()); speak(new Cat()); } static void speak(Animal animal) { animal.speak(); } 示例2： //Runnable.java public interface Runnable { void run(); } //Pig.java public class Pig implements Runnable { @Override public void run() { System.out.println(&quot;Pig---run&quot;); } } //Person.java public class Person implements Runnable { @Override public void run() { System.out.println(&quot;Person---run&quot;); } } //Main.java public class Main { public static void main(String[] args) { run(new Pig()); run(new Person()); } static void run(Runnable runnable) { runnable.run(); } } 类方法调用细节 Java中子类重写父类方法覆盖的是实例方法不是类方法（静态方法），类方法的调用只和类相关。 示例： //Animal.java public class Animal { public static void run() { System.out.println(&quot;Animal---run&quot;); } } //Dog.java public class Dog extends Animal { public static void run() { System.out.println(&quot;Dog---run&quot;); } } //Main.java public class Main { public static void main(String[] args) { Dog.run(); Animal.run(); Dog dog1 = new Dog(); dog1.run(); Animal dog2 = new Dog(); dog2.run(); } } 父类声明子类实例化（成员变量的访问细节） 理解： 使用父类类型的引用指向子类的对象。 该引用只能调用父类中定义的方法和变量。 如果子类中重写了父类的一个方法，那么在调用这个方法的时候，将会调用子类中的这个方法。（动态连接、动态调用） 变量不能被重写（覆盖），“重写”的概念只针对方法，如果在子类中“重写“了父类中的变量，那么编译时会报错。 示例： //Person.java public class Person { public int age = 1; public int getPAge() { return age; } } //Student.java public class Student extends Person { public int age = 2; public int getSAge() { return age; } } //Teacher.java public class Teacher extends Person { public int age = 3; @Override public int getPAge() { return age; } public int getTAge() { return age; } } //Main.java public class Main { public static void main(String[] args) { Student stu1 = new Student(); System.out.println(stu1.age); System.out.println(stu1.getPAge()); System.out.println(stu1.getSAge()); System.out.println(&quot;----------&quot;); Person stu2 = new Student(); System.out.println(stu2.age); System.out.println(stu2.getPAge()); System.out.println(&quot;**********&quot;); Teacher tea1 = new Teacher(); System.out.println(tea1.age); System.out.println(tea1.getPAge()); System.out.println(tea1.getTAge()); System.out.println(&quot;----------&quot;); Person tea2 = new Teacher(); System.out.println(tea2.age); System.out.println(tea2.getPAge()); } } 参考：Teingi. 【java基础】——java中父类声明子类实例化 instanceof 可以通过instanceof判断某个类型是否属于某种类型 示例： //Animal.java public class Animal {} //Cat.java public class Cat extends Animal { public void miao() { System.out.println(&quot;Cat---miao&quot;); } } //Dog.java public class Dog extends Animal { public void wang() { System.out.println(&quot;Dog---wang&quot;); } } //Main.java public class Main { public static void main(String[] args) { speak(new Dog()); speak(new Cat()); } static void speak(Animal animal) { if (animal instanceof Dog) { ((Dog)animal).wang(); }else if (animal instanceof Cat) { ((Cat)animal).miao(); } } } 匿名类（Anonymous Class） 当接口、抽象类的实现类，在整个项目中只用过一次，可以考虑使用匿名类。 示例： //Eatable.java public interface Eatable { String name(); int energy(); } //Person.java public class Person { public void eat(Eatable e) { System.out.println( &quot;eat---&quot; + e.name() +&quot;---&quot; + e.energy()); } } //Main.java public class Main { public static void main(String[] args) { Person person = new Person(); person.eat(new Eatable() { @Override public String name() { return &quot;Apple&quot;; } @Override public int energy() { return 100; } }); } } 使用注意 匿名类不能定义除编译时常量以外的任何static成员。 匿名类只能访问final或者有效final的局部变量。 匿名类可以直接访问外部类中的所有成员（即使被声明为private）。匿名类只有在实例相关的代码块中使用，才能访问外部类中的实例成员（实例变量、实例方法）。 匿名类不能自定义构造方法，但可以有初始化块。 匿名类常用于：代码传递、过滤器、回调。 常见用途及伪代码示例 传递代码：写一个工具类，统计某一段代码的执行时间。 目录结构如图所示： //Times.java package com.orangestudio.util; public class Times { public interface Block{ void execute(); } public static void test(Block block) { long begin = System.currentTimeMillis(); block.execute(); long end = System.currentTimeMillis(); double duration = (end - begin) / 1000.0; System.out.println(&quot;耗时：&quot; + duration + &quot;s&quot;); } } //Main.java package com.orangestudio; import com.orangestudio.util.Times; import com.orangestudio.util.Times.Block; public class Main { public static void main(String[] args) { Times.test(new Block() { @Override public void execute() { test(); } }); } static void test() { int age = 100000; String string = &quot;&quot;; for (int i = 0; i &lt; age; i++) { string += i; } } } 回调：根据URL发送一个异步请求（开启一条子线程），请求完毕后进行一些操作。 目录结构如图所示： //Networks.java package com.orangestudio.util; public class Networks { public interface Block{ void sucess(Object reponse); void failure(); } public static void get(String url, Block callback) { // 假设传递成功 boolean result = true; if (result) { Object reponse = null; callback.sucess(reponse); } else { callback.failure(); } } } //Main.java package com.orangestudio; import com.orangestudio.util.Networks; import com.orangestudio.util.Networks.Block; public class Main { public static void main(String[] args) { Networks.get(&quot;htps://xxxxxx.com?name=qwe&amp;age=18&quot;, new Block() { @Override public void sucess(Object reponse) { System.out.println(&quot;请求成功。&quot;); } @Override public void failure() { System.out.println(&quot;请求失败。&quot;); } }); } } 过滤器：传入文件夹地址，将文件夹下包含类的文件名过滤出来。 目录结构如图所示： //Files.java package com.orangestudio.util; public class Files { public interface Filter { boolean accept(String filename); } public static String[] getAllFilenames(String dir, Filter filter) { // 1. 先获取dir文件夹下的所有文件名 String[] allFilenames = {}; // 2. 进行过滤 for(String filename : allFilenames) { if (filter.accept(filename)) { // 将这个文件名封装起来 } } // 3. 返回所有装起来的文件名 return null; } } //Main.java package com.orangestudio; import com.orangestudio.util.Files; import com.orangestudio.util.Files.Filter; public class Main { public static void main(String[] args) { Files.getAllFilenames(&quot;C:&quot;, new Filter() { @Override public boolean accept(String filename) { return filename.contains(&quot;类&quot;); } }); } } 排序 可以使用JDK自带的java.util.Arrays类对数组进行排序 示例： //Main.java import java.util.Arrays; import java.util.Comparator; public class Main { public static void main(String[] args) { Integer[] array = {33, 22, 11, 77, 66, 99}; Arrays.sort(array); System.out.println(Arrays.toString(array)); Arrays.sort(array, new Comparator&lt;Integer&gt;() { @Override public int compare(Integer o1, Integer o2) { return o2 - o1; } }); System.out.println(Arrays.toString(array)); } } 关于compare()的返回值 等于0，o1==o2 大于0，o1&gt;o2 小于0，o1&lt;o2 Comparable vs Comparator 如果数组元素本身具备可比较性（实现了java.util.Comparable接口） 可以直接使用Arrats.sort方法进行排序 java.util.Comparator的存在意义 可以在不修改类源代码的前提下，修改默认的比较方式（比如官方类、第三方类） 可以让一个类提供多种比较方式 Lambda Expression Lambda表达式是Java8开始才有的语法，发音：美 [ˈlæmdə] 函数式接口（Functional Inferface） 函数式接口（Functional Inferface）:只包含一个抽象方法的接口 可以在接口上面加@FunctionalInterface注解，表示它是一个函数式接口 当匿名类实现的是函数式接口时，可以使用Lambda表达式进行简化 Lambda表达式格式： (参数列表) -&gt; { 代码 return xxx; } 书写规则： 参数列表可以省略参数类型 当只有一条语句时，可以省略大括号、分号、return 当只有一个参数时，可以省略小括号 当没有参数时，不能省略小括号 示例1： 对之前 “传递代码：写一个工具类，统计某一段代码的执行时间” 进行优化。 目录结构如图所示： //Times.java package com.orangestudio.util; public class Times { @FunctionalInterface public interface Block{ void execute(); } public static void test(Block block) { long begin = System.currentTimeMillis(); block.execute(); long end = System.currentTimeMillis(); double duration = (end - begin) / 1000.0; System.out.println(&quot;耗时：&quot; + duration + &quot;s&quot;); } } //Main.java------只改动了这里 package com.orangestudio; import com.orangestudio.util.Times; public class Main { public static void main(String[] args) { Times.test(() -&gt; { int age = 100000; String string = &quot;&quot;; for (int i = 0; i &lt; age; i++) { string += i; } }); } } 示例2： 写一个工具类，实现两数相加功能，并最后输出。 目录结构如图所示： //Calculators.java package com.orangestudio.util; public class Calculators { @FunctionalInterface public interface Calculator { int calculate(int v1, int v2); } public static void execute(int v1, int v2, Calculator c) { System.out.println(c.calculate(v1, v2)); } } //Main.java package com.orangestudio; import com.orangestudio.util.Calculators; public class Main { public static void main(String[] args) { Calculators.execute(10, 20, (int v1, int v2) -&gt; { return v1 + v2; }); Calculators.execute(11, 22, (v1, v2) -&gt; v1 + v2); } } 使用注意： Lambda只能访问final或者有效final的局部变量 Lambda没有引入新的作用域，匿名类引入了新的作用域 示例： //Testable.java @FunctionalInterface public interface Testable { void test(int v); } //OuterClass.java public class OuterClass { private int age = 1; public class InnerClass { private int age = 2; void inner() { // int v = 4; //Error! Testable t = v -&gt; { System.out.println(v); System.out.println(age); System.out.println(this.age); System.out.println(InnerClass.this.age); System.out.println(OuterClass.this.age); }; t.test(3); } } public static void main(String[] args) { new OuterClass().new InnerClass().inner(); } } 方法引用（Method Reference） 如果Lambda中的内容仅仅是调用某个方法，可以使用**方法引用(Method Reference)**来简化。 引用类方法 //Testable.java @FunctionalInterface public interface Testable { int test(int v1,int v2); } //Main.java public class Main { public static void main(String[] args) { Testable t1 = (v1, v2) -&gt; Math.max(v1,v2); System.out.println(t1.test(10, 20)); Testable t2 = Math::max; System.out.println(t2.test(10, 20)); } } 引用特定对象实例方法 //Testable.java @FunctionalInterface public interface Testable { void test(int v); } //Person.java public class Person { public void setAge(int age) { System.out.println(&quot;Person - setAge - &quot; + age); } } //Main.java public class Main { static void execute(Testable t, int v) { t.test(v); } public static void main(String[] args) { execute(v -&gt; System.out.println(v), 10); execute(v -&gt; new Person().setAge(v), 10); execute(System.out::println, 20); execute(new Person()::setAge, 20); } } 引用特定类型的任意对象的实例方法 //Main.java import java.util.Arrays; public class Main { public static void main(String[] args) { String[] strings = {&quot;Jack&quot;, &quot;james&quot;, &quot;Apple&quot;, &quot;abort&quot;}; Arrays.sort(strings, (s1,s2) -&gt; s1.compareToIgnoreCase(s2)); System.out.println(Arrays.toString(strings)); Arrays.sort(strings, String::compareToIgnoreCase); System.out.println(Arrays.toString(strings)); } } 引用构造方法 //Testable.java public interface Testable { Object test(int v); } //Person.java public class Person { public Person(int age) { System.out.println(&quot;Person - &quot; + age); } } //Main.java public class Main { public static void main(String[] args) { Testable t1 = v -&gt; new Person(v); System.out.println(t1.test(18)); Testable t2 = Person::new; System.out.println(t2.test(18)); } } 引用当前类中定义的实例方法 //Testable.java public interface Testable { void test(int v); } //Person.java public class Person { public void setAge(int age) { System.out.println(&quot;setAge - &quot; + age); } public void show() { Testable t1 = v -&gt; setAge(v); t1.test(10); Testable t2 = this::setAge; t2.test(10); } } //Main.java public class Main { public static void main(String[] args) { new Person().show(); } } 引用父类中定义的实例方法 //Testable.java public interface Testable { void test(int v); } //Person.java public class Person { public void setAge(int age) { System.out.println(&quot;Person - setAge - &quot; + age); } } //Student.java public class Student extends Person { @Override public void setAge(int age) { System.out.println(&quot;Student - setAge - &quot; + age); } public void show() { Testable t1 = v -&gt; super.setAge(v); t1.test(10); Testable t2 = super::setAge; t2.test(10); } } //Main.java public class Main { public static void main(String[] args) { new Student().show(); } } ","link":"https://bujreny.github.io/post/2mian-xiang-dui-xiang/"},{"title":"六个简单常见的基础题","content":"六个简单常见的基础题 斐波那契数列 描述 大家都知道斐波那契数列，现在要求输入一个正整数 n，请你输出斐波那契数列的第 n 项。 斐波那契数列具体为：1，1，2，3，5，8，13，... 即从第三项开始每一项为前两项的和。 输入描述： 一个正整数n 输出描述： 输出一个正整数。 import java.util.Scanner; public class Main { public static void main(String[] args) { int n, a, b, c; a = 1; b = 1; c = 2; Scanner scanner = new Scanner(System.in); n = scanner.nextInt(); for (int i = 0; i &lt; n - 1; i++) { if(n == 1 || n == 2) { break; } else { // 在这个循环开始之前，第i项为a，b为第i+1项，c为第i+2项 c = a + b; a = b; b = c; } } System.out.println(a); } } 求最大公约数和最小公倍数 描述： 输入两个正整数,求这两个数的最大公约数和最小公倍数。 输入描述： 两个正整数m，n 输出描述： m，n的最大公约数和最小公倍数 import java.util.Scanner; public class Main { public static void main(String[] args) { int m, n; Scanner scanner = new Scanner(System.in); m = scanner.nextInt(); n = scanner.nextInt(); // 最大公约数 for (int i = Math.min(m, n); i &gt; 0; i--) { if (m % i == 0 &amp;&amp; n % i == 0) { System.out.print(i + &quot; &quot;); break; } } // 最小公倍数 for (int i = 1; i &lt;= n; i++) { if ((m * i) % n == 0) { System.out.print(m * i); break; } } } } 数组排序 描述 输入一个正整数n,输入一个含n个元素数组，按对这个数进行从小到大的排序。数组长度为0-20。 输入描述： 数组元素个数n 和 数组元素 输出描述 排好序的若干整数 import java.util.Scanner; public class Main { public static void main(String[] args) { int n; int[] arr = new int[20]; Scanner scanner = new Scanner(System.in); n = scanner.nextInt(); for (int i = 0; i &lt; n; i++) { arr[i] = scanner.nextInt(); } for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n - 1 - i; j++) { if (arr[j] &gt; arr[j+1]) { int exchange; exchange = arr[j]; arr[j] = arr[j+1]; arr[j+1] = exchange; } } } for (int i = 0; i &lt; n; i++) { System.out.printf(&quot;%d &quot;, arr[i]); } } } 两数之和 描述： 给定一个数组(1, 3, 5, 7, 9, 11)，用户输入目标值target，请在数组中找到,两个数之和为target的数，返回数组下标，没有则返回Not Found。 输入描述： 一个整数target 输出描述： 两个数组下标 Not Found import java.util.Scanner; public class Main { public static void main(String[] args) { int[] arr = {1, 3, 5, 7, 11}; int left, right, target; left = 0; right = 4; target = new Scanner(System.in).nextInt(); while (left &lt; right) { if(target == arr[left] + arr[right]) { break; }else if(target &lt; arr[left] + arr[right]) { right--; }else { left++; } } if (left &lt; right) { System.out.printf(&quot;%d %d&quot;, left, right); }else { System.out.println(&quot;Not Found&quot;); } } } 门类继承题 描述： 编写代码，实现如下功能： 定义一个门类Door， 包含3个属性：宽度width 和 高度height ，颜色color。 包含2个方法：开门和关门。 开门方法：输出“门已经打开，请进！”。 关门方法：输出“门已经关闭，禁止进入！”。 定义一个木头门WOOD，继承Door 重写父类开门方法：输出门的高度 宽度 颜色 +“门已经打开，请进！” 重写父类关门方法：输出门的高度 宽度 颜色 +“门已经关闭，禁止进入！” 定义一个测试类，测试类定义一个main方法。分别创建 门对象 和 木头门对象， 为创建的木头门对象属性赋值, 调用开门和关门两个方法。 // Door.java public class Door { private int width; private int height; private String color; public void openDoor() { System.out.println(&quot;门已经打开，请进！&quot;); } public void closeDoor() { System.out.println(&quot;门已经关闭，禁止进入！&quot;); } public int getWidth() { return width; } public void setWidth(int width) { this.width = width; } public int getHeight() { return height; } public void setHeight(int height) { this.height = height; } public String getColor() { return color; } public void setColor(String color) { this.color = color; } } // Wood.java public class Wood extends Door { @Override public void openDoor() { System.out.printf(&quot;高度为：%d，宽度为：%d，颜色为：%s，门已经打开，请进！\\n&quot;, getHeight(), getWidth(), getColor()); } @Override public void closeDoor() { System.out.printf(&quot;高度为：%d，宽度为：%d，颜色为：%s，门已经关闭，禁止进入！\\n&quot;, getHeight(), getWidth(), getColor()); } } // Main.java public class Main { public static void main(String[] args) { Door door = new Door(); door.openDoor(); door.closeDoor(); Wood wood = new Wood(); wood.setColor(&quot;橙色&quot;); wood.setHeight(5); wood.setWidth(2); wood.openDoor(); wood.closeDoor(); } } 抽象类：汽车的轮子 描述： 请创建一个抽象类 Vehicle ，添加 NoOfWheels 抽象方法，并在 Vehicle的子类 Car 和 Motorbike 中重写 NoOfWheels 方法，让其输出其有几个轮子。在测试类中分别创建两个子类的对象并调用重写的方法。 输入描述： 无输入 输出描述： This car has four wheels This Motorbike has two wheels // Vehicle.java public abstract class Vehicle { public abstract void noOfWheels(); } // Car.java public class Car extends Vehicle { @Override public void noOfWheels() { System.out.println(&quot;This car has four wheels.&quot;); } } // Motorbike.java public class Motorbike extends Vehicle { @Override public void noOfWheels() { System.out.println(&quot;This Motorbike has two wheels.&quot;); } } // Main.java public class Main { public static void main(String[] args) { Car car = new Car(); car.noOfWheels(); Motorbike motorbike = new Motorbike(); motorbike.noOfWheels(); } } ","link":"https://bujreny.github.io/post/liu-ge-jian-dan-chang-jian-de-ji-chu-ti/"},{"title":"1.基础语法","content":"基础语法 关于左大括号 { 的位置 第一种叫K&amp;R风格，第二种叫微软风格。 这是两种不同的风格，微软风格出现比较晚，个人比较喜欢第一种。 注释 Java的三种注释格式： 单行注释 多行注释 文档注释 注意：多行注释不能进行嵌套。 数据类型 数据类型分为两大类 基本类型 引用类型 基本类型(Primitive Type) 名称 解释说明 byte 8-bit的整数，取值范围是[-128,127] short 16-bit的整数，取值范围是[-32768,32767] int 32-bit的整数，取值范围是- 2 的31次方到 2 的31次方-1 long 64-bit的整数，取值范围是- 2 的63次方到 2 的63次方-1 float 单精度32-bit IEEE 754 浮点数，取值范围是[1.40E-45F,3.4028235E38F] double 双精度64-bit IEEE 754 浮点数，取值范围是[4.9E-324,1.7976961348623157E308] boolean 布尔类型，有true、false两个值 char 单个16-bit的Unicode字符 引用类型(Reference Type) 引用类型的值是对对象的引用。 字面量 整数 // 十进制 byte v1 = 123; // 二进制（或者0B11001） short v2 = 0b11001; // 十六进制（或者0XF78A、0Xf78a） int v3 = 0xF78A; // 以用L或者l结尾的表示long类型（或者199l） long v4 = 199L; 浮点数 // 以F或者f结尾表示float类型（或者123.4f） float v5 = 123.4F; // 以D或者d结尾表示double类型（或者123.4d） double v6 = 123.4D; // 默认就是double类型 double v7 = 123.4; // 可以用科学计数法（E或者e） float v8 = 1.234E2F; double v9 = 1.234e2; 字符和字符串 // 用单引号表示字符 char v10 = 'A'; // 用双引号表示字符串 String v11 = &quot;ABCD&quot;; 布尔 boolean v12 = true; boolean v13 = false; 空值 String string = null; String空字符串与空值的区别 首先需要注意的是String是引用类型。 String str1 = &quot;ABCD&quot;; String str2 = &quot;&quot;; // 空串 String str3 = null; 由图可知str1指向了一个字符串&quot;ABCD&quot;,str2指向了一个空字符串&quot;&quot;，str3没有任何指向是一个空值。 转义序列（转义字符） 在数字中使用下划线 从Java7开始， 可以给数字添加下划线增强可读性，下划线不会影响数字的值。 int v14 = 1_0000_0000; int v15 = 0xFF_EC_DE_5E; int v16 = 0b11010010_01101001_10010100_10010010; double v17 = 1.23_45_67; long v18 = 1___0000_0000; 需要有以下几点注意： 不能再浮点数的小数点前后使用下划线 不能再数字的开头和末尾使用下划线 不能再X、B、F、D、L、E等特殊字母前后使用下划线 变量的初始化 任何变量在使用之前必须要先初始化（赋值）。 局部变量需要程序员手动初始化 **非局部变量（实例变量、类变量）**编译器会自动给未初始化的变量设置一个初始值。 运算符 运算符及其优先级 运算符 优先级 后缀 expr++ expr-- 一元（单目） ++expr --expr +expr -expr ~ ! 乘除模 * / % 加减 + - 位移 &lt;&lt; &gt;&gt; &gt;&gt;&gt; 关系 &lt; &gt; &lt;= &gt;= instanceof 等价 == != 按位与 &amp; 按位异或 ^ 按位或 | 逻辑与 &amp;&amp; 逻辑或 || 三元（三目） ? : 赋值 = += -= *= /= %= &amp;= ^= |= &lt;&lt;= &gt;&gt;= &gt;&gt;&gt;= 注意： 多个优先级一样的运算符一起使用时，按照结合性运算： 赋值运算符结合性是从右往左 其他运算符结合性是从左往右 为了保证运算符按照预期执行，尽量多使用小括号 算数表达式的结果必须被使用 关于赋值运算符结合性演示示例： //此示例可验证赋值运算符的结合性是从右往左 public class Operator { public static void main(String[] args) { int b = 10; int age = b += 30; System.out.println(age); } } 运行结果： 字符串拼接 可以使用 + 进行字符串的拼接 int age = 18; String name = &quot;Jack&quot;; double height = 1.78; System.out.println( &quot;My name is &quot; + name + &quot;, age is &quot; + age + &quot;, height is &quot; + height); 位运算 &gt;&gt;与&gt;&gt;&gt; &gt;&gt;(有符号右移)：最左用符号位补齐 &gt;&gt;&gt;(无符号位移)：最左用0补齐 二进制最高位（最左端）为符号位：0代表正，1代表负 System.out.println(-128 &gt;&gt; 2); System.out.println(-128 &gt;&gt;&gt; 2); 注意：对正数来说 &gt;&gt; 和 &gt;&gt;&gt; 是一样的 &amp;、|、^ &amp; （与）从高位开始比较，两位都为1结果才为1 ^（异或）从高位开始比较，两位相同则为0，不同则为1 |（或）从高位开始比较，有一个为1则为1，否则为0 布尔类型也可以使用这三个运算符 &amp;、|、^演示： int age1 = 0b10011; int age2 = 0b10110; int age3 = age1 &amp; age2; int age4 = age1 | age2; int age5 = age1 ^ age2; System.out.println(Integer.toBinaryString(age1)); System.out.println(Integer.toBinaryString(age2)); System.out.println(&quot;---------------&quot;); System.out.println(Integer.toBinaryString(age3)); System.out.println(Integer.toBinaryString(age4)); System.out.println(Integer.toBinaryString(age5)); System.out.println(true &amp; false); System.out.println(true &amp; true); System.out.println(false &amp; false); System.out.println(&quot;---------------&quot;); System.out.println(true | false); System.out.println(true | true); System.out.println(false | false); System.out.println(&quot;---------------&quot;); System.out.println(true ^ false); System.out.println(true ^ true); System.out.println(false ^ false); 通过观察发现在进行布尔类型的运算时，&amp;、|似乎与&amp;&amp;、||的作用一样。 但其实对比&amp;&amp;、||，&amp;、|少了短路功能。 短路功能演示示例： public class Operator { public static boolean getBoolean() { System.out.println(&quot;getBoolean&quot;); return true; } public static void main(String[] args) { System.out.println(true &amp;&amp; getBoolean()); System.out.println(&quot;------------------&quot;); System.out.println(false &amp;&amp; getBoolean()); System.out.println(&quot;------------------&quot;); System.out.println(true &amp; getBoolean()); System.out.println(&quot;------------------&quot;); System.out.println(false &amp; getBoolean()); } } 可以看到当&amp;&amp;前面是false时后面就不会调用getBoolean()方法，而&amp;前面是false的时候则会继续调用。||和|则是前面是true时，||会短路，|不会短路。 数据类型转换 拓宽基本类型转换（隐式转换） 范围小的转换为数据范围大的，可以自动转换。 一元数字提升 简单来说就是将byte、short、char类型的数字进行一元某些一元运算时自动提升为int类型。 执行一元数字提升的情况： 数组的索引（数组索引必须用int） 一元运算符+、-（表示数字正负） 按位取反~ 位移（&lt;&lt;、&gt;&gt;、&gt;&gt;&gt;） 部分示例： char c1 = 'A'; System.out.println(c1); System.out.println(+c1); char c1 = 'A'; char c2 = +c1;//报错 char c3 = 65;//不会报错 第二行代码报错：Type mismatch：cannot convert from int to char. 二元数字提升 提升一个或两个数字：可以理解为当多个数据数据范围不同的变量进行运算的时候，会自动转换为数字范围大的那一个。但是如果是byte、short、char之间的运算会自动转为int。 执行二元数字提升情况： 加（+）、减（-）、乘（*）、除（/）、取余（%） 比较（&lt;、&lt;=、&gt;、&gt;=） 判等（==、!=） 位运算（&amp;、^、|） 三目（?:） 注意：复合赋值运算自带数据类型转换。示例如下： byte v1 = 1; v1 = v1 + 1; v1 += 1; 第二行代码会报错：Type mismatch: cannot convert from int to byte. 窄化基本类型转换（强制转换） 数据范围大的转为数据范围小的，可能会丢失精度和范围，需要强制转换。（不符合上面拓宽基本类型转换规则的图示） 强制转换示例： short s = 512; char c = (char) s; byte b = (byte) c; double d = 1.23; float f = (float) d; int i = (int) d; **注意：**布尔类型不能与上述提到的数据类型转换。 关键字和标识符 关键字 48个关键字：abstract、assert、boolean、break、byte、case、catch、char、class、continue、default、do、double、else、enum、extends、final、finally、float、for、if、implements、import、int、interface、instanceof、long、native、new、package、private、protected、public、return、short、static、strictfp、super、switch、synchronized、this、throw、throws、transient、try、void、volatile、while 2个保留字：goto、const（在java里面还没有被用到） 3个特殊直接量：true、false、null 标识符 标识符：变量名、方法名、类名等，命名规则如下： 不限长度的Java字母、java数字序列，但必须以Java字母开头（区分大小写） 不能使用关键字 不能使用字面量true、false、null Java字母：Character.isJavaIdentifierStart方法返回true的字符，包括ASCII中的AZ、az、美元符（$）、下划线（_），中文，韩文，日文等字符。 Java字母或者Java数字：Character.isJavaIdentifierStart方法返回true的字符，Java数字包括ASCII中的0~9。 命名建议 变量名、方法名：小驼峰，比如myNamaAndAge 类名：大驼峰，比如MyNameAndAge 常量：比如MY_NAME_AND_AGE 数组 数组的创建 // 推荐使用 char[] arr 格式定义数组 // 不推荐使用 char arr[] 格式定义数组 int[] arr1; int[] arr2 = {}; // 空数组 int arr3[] = {}; // 空数组 // 定义的时候指定数组元素 int[] arr4 = new int[] { 1, 2, 3, 4 }; int[] arr5 = { 1, 2, 3, 4 }; // 定义的时候指定数组长度 int[] arr6 = new int[4]; arr6[0] = 1; arr6[1] = 2; arr6[2] = 3; arr6[3] = 4; // 多维数组 int[][][] arr7; int[] arr8[][]; 注意：在Java中，字符数组 != 字符串 字符数组： char[] 字符串：String 数组的内存 现有下面一段代码： public static void main(String[] args) { int[] array = new int[] { 11, 22, 33 }; System.out.println(array); } 当main方法运行时，会分配一段栈帧给main方法，然后main方法在自己的栈帧里面存放array这个引用变量，array存放的是第一个元素的地址，指向堆空间里存array数组元素的位置。 注意： Java数组属于引用类型 数组元素存放在堆空间 Java的堆内存申请会自动进行初始化 数组的遍历 int[] arr = { 11, 22, 33, 44 }; for (int i = 0; i &lt; arr.length; i++) { System.out.println(arr[i]); } for (int element : arr) { System.out.println(element); } **注意：**直接打印数组会得到数组的哈希值。 访问数组的原理：随机访问、速度非常快、O(1)。 示例：假设array的地址为0x1110,要访问array[2] array[2] -&gt; 0x1110 + 2 * 4 , 然后直接去 0x1118访问 方法 方法的书写格式 修饰符 返回值类型 方法名(参数列表) { 方法体 } 可变参数 注意： 可变参数必须是方法中的最后一个参数，实际上是以数组的形式传入的。 如果不传入可变参数，那么在调用方法时是空数组，而不是null 可变参数示例： public static void main(String[] args) { System.out.println(sum( 1, 2, 3, 4 )); } public static int sum(int... numbers) { int result = 0; for (int i : numbers) { result += i; } return result; } JDK自带的System.out.printf方法使用了可变参数，格式字符串参考API文档的java.util.Formatter类。 String name = &quot;Jack&quot;; int age = 20; System.out.printf(&quot;My name is %s, my age is %d.&quot;, name, age); 参数的传递 基本类型 基本类型作为参数是值传递 基本类型作为返回值，返回的是值 引用类型 引用类型作为参数是引用传递（地址传递） 引用类型作为返回值，返回的是引用（地址） 方法签名 方法签名由两部分组成：方法名、参数类型 示例： // 下面这个方法的方法签名是：sum(int, long, double) public static double sum(int i, long l, double d) { return i + l + d; } **注意：**在同一个类中，不能定义两个方法签名一样的方法。 方法的重载 Java的方法支持重载：方法名相同，方法签名不同（参数的个数不同、参数的类型不同）。 **注意：**重载与返回值类型、参数名称无关。 示例： public static int sum(int a, int b ) { return a + b; } public static double sum(double a, double b) { return a + b; } 栈帧 栈帧随着方法的调用而创建，随着方法的结束而销毁，存储了方法的局部变量信息。 示例： public static void main(String[] args) { test1(10); test2(20); } public static void test1(int v) {} public static void test2(int v) { test3(30); } public static void test3(int v) {} 上述代码栈帧创建与销毁过程如下图所示： 由图可知，调用方式时创建了栈帧，方法调用结束后销毁了栈帧。 递归调用 示例： public static void main(String[] args) { System.out.println(sum(4)); } public static int sum(int n) { if (n &lt;= 1) { return n; } return n + sum(n - 1); } 这段程序的栈帧： 注意：此图中的黑色字是不存在的。知识为了方便理解。 注意： 如果递归调用没有终止，将会一直消耗栈空间，最终导致内存溢出（Stack Overflow）。 所以必须要有一个明确的结束递归的条件，也叫边界条件、递归基。 ","link":"https://bujreny.github.io/post/1ji-chu-yu-fa/"},{"title":"求立方体类Box的表面积和体积","content":"求立方体类Box的表面积和体积 题目 此题作为重学JavaSE的第一道基础题。 设计一个立方体类Box，定义三个属性，分别是长，宽，高。定义二个方法，分别计算并输出立方体的体积和表面积。 代码 //Box.java public class Box { private int width; private int height; private int length; private int area; private int volume; public Box(int width, int height, int length) { this.width = width; this.height = height; this.length = length; } public Box() { } public int getWidth() { return width; } public void setWidth(int width) { this.width = width; } public int getHeight() { return height; } public void setHeight(int height) { this.height = height; } public int getLength() { return length; } public void setLength(int length) { this.length = length; } public int getArea() { return area; } public void setArea(int area) { this.area = area; } public int getVolume() { return volume; } public void setVolume(int volume) { this.volume = volume; } } //Calculator.java public class Calculator { public static int area(int length, int width, int height) { int area = length * width + length * height + width * height; area *= 2; return area; } public static int volume(int length, int width, int height) { int volume = length * width * height; return volume; } } //Operator.java import java.util.Scanner; public class Operator { public void operate(Box box){ Scanner scanner = new Scanner(System.in); int length = scanner.nextInt(); int width = scanner.nextInt(); int height = scanner.nextInt(); box.setArea(Calculator.area(length, width, height)); box.setVolume(Calculator.volume(length, width, height)); scanner.close(); } } //Main.java public class Main { public static void main(String[] args) { Operator operator = new Operator(); Box box = new Box(); operator.operate(box); System.out.println(&quot;area: &quot; + box.getArea() + &quot;\\nvolume: &quot; + box.getVolume()); } } 分析 类 用途 Box 用来存储立方体Box的长宽高以及面积体积等属性 Calculator 用来计算Box的面积体积 Operator 用来应对用户的输入以及类之间数据的传输 Main 创建Box对象和Operator对象以及输出结果 运行结果 总结 对好多基础知识仍不熟悉，这源于在一开始学习Java时的不认真，重学Java的计划仍需不断推进。 ","link":"https://bujreny.github.io/post/qiu-li-fang-ti-lei-box-de-bian-mian-ji-he-ti-ji/"},{"title":"匿名代码块与static代码块","content":"匿名代码块与static代码块 补充static关键词中关于静态方法块的内容。 首先看一下测试代码 public class Person { // 构造方法 Person(){ System.out.println(&quot;构造方法&quot;); } // 匿名方法块 { System.out.println(&quot;匿名方法块&quot;); } // static方法块 static { System.out.println(&quot;静态方法块&quot;); } } class Test { public static void main(String[] args) { Person person1 = new Person(); System.out.println(&quot;=======================&quot;); Person person2 = new Person(); } } 运行结果： 由运行结果可知： 在类初次被加载的时候，会最先加载静态方法块，然后加载匿名方法块，最后在加载构造方法。 但静态方法块只会加载一次，在第二次加载类时，只会加载先加载匿名方法块和构造方法。 所以也可以用匿名代码块来进行一些初始赋值，一些只进行一次的操作则放在静态代码块里。 学习之后的原理补充： 静态代码块是在这个类被初始化的时候执行，一个类第一次被主动使用时，JVM才会对类进行初始化，静态代码块是在这个类被初始化的时候执行，所以静态代码块会先于匿名代码块被执行，并且只执行一次。 编译器会将匿名代码块复制到每个构造方法的头部，所以会先于构造方法执行。 ","link":"https://bujreny.github.io/post/ni-ming-dai-ma-kuai-yu-static-dai-ma-kuai/"},{"title":"IDEA中Maven配置问题","content":"IDEA中Maven配置问题 问题 初学maven，在设置idea的maven配置时发现了一个问题。我每次创建maven项目时，无论是否修改maven配置，都会使用IDEA自带的maven。 解决这个问题，只需要先关闭项目。 在最开始的页面进入设置。 只需要在这里设置Maven的路径和其他设置，就不会有创建新项目时，Maven的配置全部恢复默认的情况。 个人理解：可以理解为打开项目时的设置为针对某一项目的设置，并不是全局设置。关闭所有项目在初始页进行设置为全局设置。 参考 Steve_hanhaiLong. IDEA中配置Maven常见问题每次都需要更改setting设置，否则使用默认Maven，完美解决Maven的配置问题！ ","link":"https://bujreny.github.io/post/idea-zhong-maven-pei-zhi-wen-ti/"}]}